/****************************************************************
	Copyright(C), 1999-2004 Raisecom, Inc.
	filename: svcdev_rc006.c，RC006协议的svc侧设备管理公共函数
	Author	: qiaoqiangguo
	version	: 1.0
	date	: 2008/6/21
	Others	:
        THIS DOCUMENT IS GENERATED BY TORNADO TOOLS refgen.exe
        EXAMPLE:
        ->torVars.bat
        ->refgen -mg -out doc svcdev_rc006.c
        ->cd doc
        ->htmllink
*****************************************************************/
#include "otpconfig.h"

#ifdef INCLUDE_SVCDEV_RC006

#include "stdio.h"
#include "string.h"
#include "macro_common.h"
#include "tmr.h"
#include "dev_common.h"
#include "ibc_rc006.h"
#include "ibc_rc006_protocol.h"
#include "svc_system.h"
#include "svcdev_rc006.h"
#include "svc_dev.h"
#include "pdt_msg_format.h"

IMPORT OTP_UINT8 dev_svc_INT_CFG_request(OTP_UINT8 *respndinfo,OTP_UINT32 *rspndLen);

/* 单盘业务模块初始化，在单盘初始化到业务模块初始化的时候被调用。
	该函数负责初始化svcdev所需要的全局变量，初始化各个业务模块用到的硬件和数据结构	*/
#ifdef  INCLUDE_SVCDEV_RC006_FILE_DOWNLOAD

#include "fileloader.h"

#include "trace.h"


ibc_payload_svcfile_manage_loaddata_global_info g_ibc_filemanege_global_info;/*IBC 文件管理通用变量*/
ibc_file_downlaod_process  g_file_downlaod_process_func; /*文件下载处理函数*/

#endif

/* 单盘局端模块处理板间消息，在单盘收到svcdev模块不能处理的局端消息的时候被调用。
	该函数要负责处理所接收到消息，根据处理结果发送相应消息
*/
IMPORT STATUS svc_NMS_msg_proc(const OTP_VOID *arg,const IBC_MSG msg,const rdev_rid* prid,
						OTP_UINT8 opcode,const OTP_UINT8 *p_data,OTP_UINT32 datalen, OTP_UINT8 *pack,
						OTP_UINT32 acklen);

/* 单盘远端模块处理板间消息，在单盘收到svcdev模块不能处理的远端消息的时候被调用。
	该函数要负责处理所接收到消息，根据处理结果发送相应消息
*/
/*IMPORT STATUS svc_rdev_NMS_msg_proc(const OTP_VOID *arg, IBC_MSG msg,const  rdev_rid* prid,
						OTP_UINT8 opcode,const OTP_UINT8 *p_data,OTP_UINT32 datalen,const OTP_UINT8 *pack,
						OTP_UINT32 acklen);*/
IMPORT STATUS svcdev_proc_dev_debug(const OTP_VOID *arg, const IBC_MSG msg, const rdev_rid* prid,	OTP_UINT8 opcode, 
								const OTP_UINT8 *p_data, OTP_UINT32 datalen, OTP_UINT8 *pack,	OTP_UINT32 acklen);
IMPORT STATUS svc_reboot(OTP_UINT32 type);

IMPORT OTP_UINT16 svc_get_devtype(const OTP_VOID *arg);

IMPORT xxx_proc_nms_msg g_ibcadp_proc_nms_msg;

/* 业务盘的槽位号、单板类型、背板总线类型、是否支持反向配置查询 */
/*IMPORT OTP_UINT8 	g_local_svc_slot;*/
/*IMPORT OTP_UINT16	g_local_svc_devtype;*/
IMPORT BOOL		g_support_reverse_cfg;

/*存储的产品名称*/
/*panwei 2012-10-18 bugID:ITS00049192 */
IMPORT OTP_CHAR g_product_name[PRO_NAME_LENGTH];

/*派生设备握手标志，用于同步，初始情况下为空，同步一次为满，中断查询或反向配置后需要清空*/
BOOL g_deriveHandshakeFlag;	

/*中断记录表，只记录中断类型，根据中断类型生成ack报文*/
svcdev_int_info g_svc_int[SVCDEV_INT_NUM_MAX];
/*支持同时最多产生16个中断*/
OTP_UINT16 g_svc_intflag = 0;

/*waitconfigdone的等待时间定时器的句柄*/
HTMR	g_svc_config_done_htmr = TMR_INVALID_HTMR;

/*从发出第一个中断到收到配置恢复结束消息之间允许的最大秒数
	如果在这段时间以内没有收到配置恢复结束消息，就再次触发配置请求
*/

/*业务盘的启动阶段,在不同的函数中公用的变量，防止被编译器优化*/
volatile svcdev_startup_stage g_svcdev_startup_stage=svcdevs_init;

LOCAL STATUS svcdev_int_init(void)
{
	g_svc_intflag = 0;
	memset(g_svc_int, 0, sizeof(g_svc_int));

	return OK;
}


/*lint -save -e826*/
/********************************************************************
* svcdev_ibc_pack_frame     - 单盘打包中断ack报文
*
* PARAMETERS参数 - As follow如下:
*		pack	--	响应数据区所用的buf地址
*		acklen	--	响应数据所用的buf长度		
*		plen	--	报文数据实际长度
* RETURN返回值:
*
*		OK 		--	响应处理成功
*		ERROR 	--	响应处理失败,有异常
*
* EXAMPLE例:
* ...
*/
LOCAL STATUS svcdev_int_pack_frame(OTP_UINT8 inttype, OTP_UINT8 *pack, OTP_UINT32 acklen, OTP_UINT32 *plen)
{
	ibc_payload_interrupt_ack *pint = NULL;
	OTP_UINT16 devtype;
	OTP_UINT32 datalen;
	datalen=0;
	NO_USE(acklen);
	if((pack == NULL) || (plen == NULL))
	{
		return ERROR;
	}
	*plen = 0;
	/*lint -save -e826*/
	pint = (ibc_payload_interrupt_ack *)pack;
	/*lint -restore*/
	devtype = svc_get_devtype(NULL);
	pint->devt =  htons(devtype);	/*中断查询肯定是Agent下发的*/
	
	switch (inttype)
	{
		case SVCDEV_INT_CFGREQUEST:
			pint->intcommon = htons(IBC_INTCOMMON_CFGREQUEST);
			pint->intprivate = 0;
			/*加入响应 净荷内容,from here*/
			(OTP_VOID)dev_svc_INT_CFG_request(pint->data,&datalen);
			*plen =sizeof(*pint)+datalen;
			return OK;
		case SVCDEV_INT_CMFFAILED:
			pint->intcommon = htons(IBC_INTCOMMON_CMDFIAIED);
			pint->intprivate = 0;
			*plen = sizeof(*pint);
			break;
		case SVCDEV_INT_RDEVURGENT:
			pint->intcommon = htons(IBC_INTCOMMON_RDEV_URGENCE);
			pint->intprivate = 0;
			*plen = sizeof(*pint);
			return OK;
		case SVCDEV_INT_RDEVDISAPPER:
			pint->intcommon = htons(IBC_INTCOMMON_RDEV_DISAPPEAR);
			pint->intprivate = 0;
			*plen = sizeof(*pint);
			return OK;
		case SVCDEV_INT_CARDREADY:
			pint->intcommon = htons(IBC_INTCOMMON_CARDREADY);
			pint->intprivate = 0;
			*plen = sizeof(*pint);
			return OK;
		case SVCDEV_INT_REQ_TRANSMIT:
			pint->intcommon = htons(IBC_INTCOMMON_REQUEST_TRANSMIT);
			pint->intprivate = 0;
			*plen = sizeof(*pint);
			return OK;
		default:
			
			break;
		
	}

	return OK;
}

/********************************************************************************
* svcdev_proc_pdt_query --处理查询产品信息的操作
*Input:
*
*	arg         --串口参数	
*	msg,		原始消息包。如果需要直接处理消息包可以用它。
				当返回值为OK时必须释放，否则不能释放。
*	slot,	 	接收到的消息的源槽位号
*	prid,		接收到消息的远端设备标识数组
*	opcode,		操作码类型
*	data,		具体消息数据("板卡类型"后面到"校验和"之前的数据，含命令字和命令块等业务信息)，
				不能释放。
*	datalen,	data中有效数据的长度	
*Output:
*	None
*Return:
*	OK			--表示执行成功
*	ERROR		--表示执行错误
*/

#ifdef INCLUDE_PRODUCT_MSG_FORMAT
LOCAL STATUS svcdev_proc_pdt_query(const OTP_VOID *arg, const IBC_MSG msg, const rdev_rid* prid,	OTP_UINT8 opcode, 
								const OTP_UINT8 *p_data, OTP_UINT32 datalen, OTP_UINT8 *pack,	OTP_UINT32 acklen)
{
	OTP_UINT32	rspdlen = 0;
	STATUS OpResoult = ERROR;
	OTP_UINT8 temp[4]={0};
		
	NO_USE(opcode);
    NO_USE(p_data);
    NO_USE(datalen);

	if( prid != NULL && prid->hop > 0)
	{
		return ERROR;
	}

    /*读取所有产品信息*/
    OpResoult = product_msg_read_all(pack+4, acklen-4, &rspdlen);

	temp[3] = rspdlen & 0xFF;
	temp[2] = (rspdlen>>8) & 0xFF;
	temp[1] = (rspdlen>>16) & 0xFF;
	temp[0] = (rspdlen>>24) & 0xFF;
	rspdlen +=4;
	memcpy(pack,temp,4);
	if(OpResoult == OK)
	{
		(OTP_VOID)ibcadp_send(arg, msg, prid, IBC_EXRSP_OK, pack,rspdlen);
		return OK;
	}
	else
	{
		(OTP_VOID)ibcadp_send(arg, msg,prid,IBC_EXRSP_OK,NULL,0);
		return ERROR;		
	}

}
#endif

/********************************************************************
* INT_ibc_response     -  中断响应, 取出中断,将中断数据放到响应数据区
*
* PARAMETERS参数 - As follow如下:
*		pack	--	响应数据区所用的buf地址
*		acklen	--	响应数据所用的buf长度		
*		plen	--	报文数据实际长度
* RETURN返回值:
*
*		OK 		--	响应处理成功
*		ERROR 	--	响应处理失败,有异常
*
* EXAMPLE例:
* ...
*/
STATUS svcdev_int_ibc_response(OTP_UINT8 *pack, OTP_UINT32 acklen, OTP_UINT32 *plen)
{
	OTP_UINT8 i = 0;

	if(g_svc_intflag == 0)
	{/*没有中断记录*/
		return ERROR;
	}
	
	for(i=0; i<SVCDEV_INT_NUM_MAX; i++)
	{
		if(g_svc_int[i].isexist)
		{
			break;
		}
	}
	if(i >= SVCDEV_INT_NUM_MAX)
	{
		/*表示中断表种没有中断情况*/
		g_svc_intflag = 0;
		
		return ERROR;
	}

	/*检查打包函数是否为空*/
	if(g_svc_int[i].intpack == NULL)
	{
		MCU_EXC_ERROR;
		return ERROR;
	}

	/*打包intack报文*/
	if(	g_svc_int[i].intpack(g_svc_int[i].type, pack, acklen, plen) != OK)
	{
		return ERROR;
	}
	
	g_svc_int[i].isexist = FALSE;
	g_svc_int[i].type = 0;
	g_svc_int[i].intpack = NULL;

	BIT_CLEAR(g_svc_intflag, (OTP_UINT16)BIT(i));

	if(g_svc_intflag == 0)
	{/*清硬件中断*/
		(OTP_VOID)CLEAR_HARDWARE_INT;
        
	}


	return OK;
}

/********************************************************************
* svcdev_int_ibc_request     -  中断响应, 取出中断,将中断数据放到响应数据区
*
* PARAMETERS参数 - As follow如下:
*		inttype	--	中断类型，功能中断占用1－16；私有中断类型值可以自己
*		intpack --	回调函数，用于网管盘查询中断时的打包函数
*	
* RETURN返回值:
*
*		OK 		--	响应处理成功
*		ERROR 	--	响应处理失败,有异常
*
* EXAMPLE例:
* ...
*/
STATUS svcdev_int_request(OTP_UINT8 inttype, int_pack_func intpack)
{
	OTP_UINT32 i = 0;

	for(i=0; i<SVCDEV_INT_NUM_MAX; i++)
	{
		if((g_svc_int[i].isexist)&&(g_svc_int[i].type == inttype))
		{/*已经触发过中断，直接返回，不再触发*/
			return OK;
		}
	}
	
	for(i=0; i<SVCDEV_INT_NUM_MAX; i++)
	{
		if(!g_svc_int[i].isexist)
		{/*记录空位置*/
			break;
		}
	}
	if(i >= SVCDEV_INT_NUM_MAX)
	{/*中断表位置不够了*/
		MCU_EXC_ERROR;
		return ERROR;
	}

	g_svc_int[i].type = inttype;
	g_svc_int[i].isexist = TRUE;
	g_svc_int[i].intpack = intpack;

	BIT_SET(g_svc_intflag, (OTP_UINT16)BIT(i));

	/*触发硬件中断*/
	(OTP_VOID)SET_HARDWARE_INT;
	
	return OK;
}


/*处理网管盘来的不支持的操作类型码，直接返回扩展响应字为IBC_EXRSP_SKIP_OPCODE
	输入参数:
		msg,		原始消息包。如果需要直接处理消息包可以用它。
					当返回值为OK时必须释放，否则不能释放。
		slot,	 	接收到的消息的源槽位号
		prid,		接收到消息的远端设备标识数组
		opcode,		操作码类型
		data,		具体消息数据("板卡类型"后面到"校验和"之前的数据，含命令字和命令块等业务信息)，
					不能释放。
		datalen,	data中有效数据的长度
	返回值:
		OK,			本函数消化了msg消息，在返回前已经释放了msg,IBC适配层模块不能再释放该消息
		ERROR,		本函数没有消化msg消息，在返回后由IBC适配层模块释放msg消息
*/
STATUS svcdev_proc_unsupport_msg(const OTP_VOID *arg, IBC_MSG msg,const rdev_rid* prid,OTP_UINT8 opcode,
						const OTP_UINT8 *data,OTP_UINT32 datalen)
{
	NO_USE(data);
	NO_USE(datalen);
	NO_USE(opcode);
	NO_USE(data);
	NO_USE(datalen);

 	if( ibcadp_send(arg, msg,prid,IBC_EXRSP_SKIP_OPCODE, NULL,0) != OK )
	{
		return ERROR;
	}
/*	(OTP_VOID)shield_unreferedError_Func(arg, msg, prid, opcode,data,datalen, NULL, 0);*/
	return OK;
}

/*处理网管盘来的中断消息
	输入参数:
		msg,		原始消息包。如果需要直接处理消息包可以用它。
					当返回值为OK时必须释放，否则不能释放。
		slot,	 	接收到的消息的源槽位号
		prid,		接收到消息的远端设备标识数组
		opcode,		操作码类型
		data,		具体消息数据("板卡类型"后面到"校验和"之前的数据，含命令字和命令块等业务信息)，
					不能释放。
		datalen,	data中有效数据的长度
	返回值:
		OK,			本函数消化了msg消息，在返回前已经释放了msg,IBC适配层模块不能再释放该消息
		ERROR,		本函数没有消化msg消息，在返回后由IBC适配层模块释放msg消息
*/
LOCAL STATUS svcdev_proc_interrupt(OTP_VOID *arg, IBC_MSG msg,const rdev_rid* prid,OTP_UINT8 opcode,
						const OTP_UINT8 *data,OTP_UINT32 datalen, OTP_UINT8 *pack, OTP_UINT32 acklen)
{
	OTP_UINT32 len = 0;
	struct ibc_payload_interrupt_ack *pintack=NULL;
	OTP_UINT16 devtype;
	NO_USE(opcode);
	NO_USE(arg);
	NO_USE(data);
	NO_USE(datalen);

	/*没有握手，返回握手不匹配*/
	if(!g_deriveHandshakeFlag)
	{
		len = 0;
		if( ibcadp_send(arg,msg,prid,IBC_EXRSP_ERROR_NOT_MATCH, pack, len) != OK )
		{
			return ERROR;
		}
		return OK;
	}

	
	/*没有中断却收到了中断消息，回应错误*/
	if( svcdev_int_ibc_response(pack, acklen, &len) != OK )
	{
		(OTP_VOID)ibcadp_send(arg,msg,prid,IBC_EXRSP_ERROR_OPCODE,NULL,0);
		return ERROR;
	}
	
	/*中断响应消息至少应该有公共部分*/
	if( len < sizeof(struct ibc_payload_interrupt_ack) )
	{
		(OTP_VOID)ibcadp_send(arg,msg,prid,IBC_EXRSP_ERROR_OPCODE,NULL,0);
		return ERROR;
	}
	/*lint -save -e826*/
	pintack = (ibc_payload_interrupt_ack *)pack;
	/*lint -restore*/
	devtype = svc_get_devtype(arg);
	/*中断响应消息至少应该填上该槽位的板卡类型*/
	if( pintack->devt!=htons(devtype))	/*中断查询肯定是Agent发的*/
	{
		/*这个打印在整理完int_ibc以后最后应该改成断言*/
		(OTP_VOID)ibcadp_send(arg,msg,prid,IBC_EXRSP_ERROR_OPCODE,NULL,0);
		return ERROR;
	}
	
	/*对配置请求消息单独处理*/
	if(pintack->intcommon == htons(IBC_INTCOMMON_CFGREQUEST))
	{
		/*配置请求以后就只等配置恢复结束消息了*/
		g_svcdev_startup_stage=svcdevs_cfgdone_waiting;
	}

	/*对单盘就绪消息单独处理*/
	if( pintack->intcommon == htons(IBC_INTCOMMON_CARDREADY))
	{
		g_svcdev_startup_stage=svcdevs_working;
	}
	
	if( ibcadp_send(arg,msg,prid,IBC_EXRSP_OK, pack, len) != OK )
	{
		return ERROR;
	}

	return OK;
}

/*************************************************************************
*svcdev_trigger_int_cfgreq       --触发中断，配置请求
*/
STATUS svcdev_trigger_int_cfgreq(void)
{
	/*既然要重新下配置就清除所有的中断，初始化中断表*/
	(OTP_VOID)svcdev_int_init();

	/*设备工作状态进入等待中断查询状态*/
	g_svcdev_startup_stage = svcdevs_int_waiting;

	/*触发中断*/
	if( svcdev_int_request(SVCDEV_INT_CFGREQUEST, svcdev_int_pack_frame)!= OK )
	{
		g_svcdev_startup_stage = svcdevs_init;
		return ERROR;
	}

	return OK;
}


/*处理网管盘来查询设备心跳
	输入参数:
		msg,		原始消息包。如果需要直接处理消息包可以用它。
					当返回值为OK时必须释放，否则不能释放。
		slot,	 	接收到的消息的源槽位号
		prid,		接收到消息的远端设备标识数组
		opcode,		操作码类型
		data,		具体消息数据("板卡类型"后面到"校验和"之前的数据，含命令字和命令块等业务信息)，
					不能释放。
		datalen,	data中有效数据的长度
	返回值:
		OK,			本函数消化了msg消息，在返回前已经释放了msg,IBC适配层模块不能再释放该消息
		ERROR,		本函数没有消化msg消息，在返回后由IBC适配层模块释放msg消息
*/
LOCAL STATUS svcdev_proc_heard_beat(const OTP_VOID *arg, IBC_MSG msg,const rdev_rid* prid,OTP_UINT8 opcode,
						const OTP_UINT8 *data,OTP_UINT32 datalen)
{
	NO_USE(opcode);
	NO_USE(data);
	NO_USE(datalen);
	
	/*发送响应消息*/
	if( ibcadp_send(arg, msg,prid,IBC_EXRSP_OK,NULL,0) != OK )
	{
		MCU_EXC_ERROR;

		return ERROR;
	}
	
	return OK;
}




/*处理网管盘来的反向配置查询消息
	输入参数:
		arg		自定义指针
		msg,		原始消息包。如果需要直接处理消息包可以用它。
					当返回值为OK时必须释放，否则不能释放。
		slot,	 	接收到的消息的源槽位号
		prid,		接收到消息的远端设备标识数组
		opcode,		操作码类型
		data,		具体消息数据("板卡类型"后面到"校验和"之前的数据，含命令字和命令块等业务信息)，
					不能释放。
		datalen,	data中有效数据的长度
	返回值:
		OK,			本函数消化了msg消息，在返回前已经释放了msg,IBC适配层模块不能再释放该消息
		ERROR,		本函数没有消化msg消息，在返回后由IBC适配层模块释放msg消息
*/
LOCAL STATUS svcdev_proc_reverse_cfg(const OTP_VOID *arg, IBC_MSG msg,const rdev_rid* prid,OTP_UINT8 opcode,
						const OTP_UINT8 *data,OTP_UINT32 datalen, OTP_UINT8 *pack,OTP_UINT32 acklen)
{
	STATUS ret=ERROR;

	NO_USE(pack);
	/* 不支持反向配置查询的单盘重启发送不支持消息，然后重启自己 */
	if( !g_support_reverse_cfg )
	{
		/* 不支持反向配置查询的单盘 */
		ret = svcdev_proc_unsupport_msg(arg, msg,prid,opcode,data,datalen);
		tmr_delay_ms(100);
		(OTP_VOID)svc_reboot(0);
		return ret;
	}
	/* 支持反向配置查询的单盘在配置恢复结束之前不能回当前配置，再次触发配置请求 */
	if( g_svcdev_startup_stage!=svcdevs_working )
	{
		/*我的配置不完整，不能给网管盘回配置，让它先跳过我*/
		ret = svcdev_proc_unsupport_msg(arg, msg,prid,opcode,data,datalen);
		return ret;
	}

	/* 支持反向配置查询的单盘在工作状态，交给业务模块来处理 */
	ret = svc_NMS_msg_proc(arg, msg,prid,opcode,data,datalen,pack,acklen);

	return ret;
}


/*处理网管盘来的配置恢复结束消息
	输入参数:
		msg,		原始消息包。如果需要直接处理消息包可以用它。
					当返回值为OK时必须释放，否则不能释放。
		slot,	 	接收到的消息的源槽位号
		prid,		接收到消息的远端设备标识数组
		opcode,		操作码类型
		data,		具体消息数据("板卡类型"后面到"校验和"之前的数据，含命令字和命令块等业务信息)，
					不能释放。
		datalen,	data中有效数据的长度
	返回值:
		OK,			本函数消化了msg消息，在返回前已经释放了msg,IBC适配层模块不能再释放该消息
		ERROR,		本函数没有消化msg消息，在返回后由IBC适配层模块释放msg消息
*/
LOCAL STATUS svcdev_proc_config_done(const OTP_VOID *arg, IBC_MSG msg,const rdev_rid* prid,OTP_UINT8 opcode,
						const OTP_UINT8 *data,OTP_UINT32 datalen)
{
	STATUS ret=ERROR;

	/*不在等待配置恢复结束消息的阶段收到了配置恢复结束消息*/
	if( g_svcdev_startup_stage!=svcdevs_cfgdone_waiting )
	{
		/*我没有要过配置，干嘛告诉我配置结束了*/
		ret = svcdev_proc_unsupport_msg(arg, msg,prid,opcode,data,datalen);
		return ret;
	}

	/*发送响应消息*/
	if( ibcadp_send(arg, msg,prid,IBC_EXRSP_OK,NULL,0) != OK )
	{
		MCU_EXC_ERROR;

		return ERROR;
	}

	if(g_svc_config_done_htmr)
	{/*如果创建过定时器，删除定时器*/
		if(tmr_delete(g_svc_config_done_htmr) != OK)
		{
			MCU_EXC_ERROR;
			return ERROR;
		}
	}

	/*进入工作状态*/
	g_svcdev_startup_stage = svcdevs_working;

	return OK;
}

LOCAL STATUS svcdev_configdone_timeout(HTMR ht, OTP_UINT32 uarg)
{
	NO_USE(ht);
	NO_USE(uarg);
	/*等待configdone消息超时，直接进入working状态*/
	g_svcdev_startup_stage = svcdevs_init;

	/*重新触发配置请求中断*/
	(OTP_VOID)svcdev_trigger_int_cfgreq();

	return OK;
}


 /*硬复位函数*/
 STATUS ResetSystem(HTMR htmr, OTP_UINT32 uarg)
{
	NO_USE(htmr);
	NO_USE(uarg);

	/*复位*/
	(OTP_VOID)svc_reboot(HARD_RESET);
	return OK;
}

 /*panwei 2011-3-10 软复位函数*/
 STATUS SoftResetSystem(HTMR htmr, OTP_UINT32 uarg)
{
	NO_USE(htmr);
	NO_USE(uarg);

	/*复位*/
	(OTP_VOID)svc_reboot(SOFT_RESET);
	return OK;
}

/*处理网管盘来的重新启动消息
	输入参数:
		msg,		原始消息包。如果需要直接处理消息包可以用它。
					当返回值为OK时必须释放，否则不能释放。
		slot,	 	接收到的消息的源槽位号
		prid,		接收到消息的远端设备标识数组
		opcode,		操作码类型
		data,		具体消息数据("板卡类型"后面到"校验和"之前的数据，含命令字和命令块等业务信息)，
					不能释放。
		datalen,	data中有效数据的长度
	返回值:
		OK,			本函数消化了msg消息，在返回前已经释放了msg,IBC适配层模块不能再释放该消息
		ERROR,		本函数没有消化msg消息，在返回后由IBC适配层模块释放msg消息
*/
LOCAL STATUS svcdev_proc_reset_hard(const OTP_VOID *arg, IBC_MSG msg,const rdev_rid* prid,OTP_UINT8 opcode,
						const OTP_UINT8 *data,OTP_UINT32 datalen)
{
	NO_USE(data);
	NO_USE(datalen);
	if( prid!=NULL && prid->hop>0 )
	{
		return ERROR;
	}

	if( ibcadp_send(arg, msg,prid,IBC_EXRSP_OK,NULL,0) != OK )
	{
		return ERROR;
	}
	/*为保证消息能发完，这里做了一个延时，在使用UART口进行数据传输时
	，可以保证数据通过串口中断发送，在利用寄存器发送数据时，使用延时
	不能实现数据的发送，所以采用创建定时器方式。sunzhongbo 20090818*/
	if (opcode ==IBC_OPCODE_RESET_HARD)
	{
		(OTP_VOID)tmr_create(1500,TMR_DEFAULT, ResetSystem, 0);
	}
	else
	{
		/*不支持软复位*/
		(OTP_VOID)tmr_create(1500,TMR_DEFAULT, SoftResetSystem, 0);
	}
	
	return OK;
}

/*******************************************************************************
* svcdev_proc_devinfo_msg
*
* DESCRIPTION:
*       处理网管盘来的业务盘版本详细信息
*
* INPUTS:
*		arg	--		void类型指针
*		msg --		原始消息包。如果需要直接处理消息包可以用它。
*					当返回值为OK时必须释放，否则不能释放。
*		slot --	 	接收到的消息的源槽位号
*		prid --		接收到消息的远端设备标识数组
*		opcode --	操作码类型
*		p_data --	具体消息数据("扩展协议头"后面到"校验和"之前)，不能释放。
*		datalen --	data中有效数据的长度
*
* OUTPUTS:
*       NONE
*
* RETURNS:
*		OK,			本函数消化了msg消息，在返回前已经释放了msg,IBC适配层模块不能再释放该消息
*		ERROR,		本函数没有消化msg消息，在返回后由IBC适配层模块释放msg消息
*
* COMMENTS:
* 	
*
*******************************************************************************/

STATUS svcdev_proc_devinfo_msg(
	const OTP_VOID *arg, 
	const IBC_MSG msg,
	const rdev_rid* prid,
	OTP_UINT8 opcode,
	const OTP_UINT8 *data,
	OTP_UINT32 datalen)
	
{
	NO_USE(arg);
	NO_USE(msg);
	NO_USE(prid);
	NO_USE(opcode);
	NO_USE(data);
	NO_USE(datalen);
/*
	ibc_payload_query_devinfo_ack *pversion = NULL;
	OTP_UINT32 pverlen=0;
	OTP_UINT16 devt;
	OTP_UINT8 ret_ibc_exp = IBC_EXRSP_OK; 
	STATUS ret=ERROR;


	pversion = (ibc_payload_query_devinfo_ack *)g_svc_detail_version;
	devt = ntohs(pversion->devt);

	if(devt != product_dev_get_devtype(slot))
	{
		return ret;
	}

	pverlen = (sizeof(ibc_payload_query_devinfo_ack) + 
			(pversion->firmwarecount * sizeof(struct firmware)) + 
			pversion->descriptionlen);
	
	if(ibcadp_send(arg, msg, prid, ret_ibc_exp, (OTP_UINT8*)pversion, pverlen) != OK )
	{
		return ERROR;
	}
*/
	if( ibcadp_send(arg, msg,prid,IBC_EXRSP_SKIP_OPCODE, NULL,0) != OK )
	{
		return ERROR;
	}
/*	(OTP_VOID)shield_unreferedError_Func(arg, msg, prid, opcode,data,datalen, NULL, 0);*/
	return OK;
}


/***********************文件下载*****************************/
#ifdef INCLUDE_SVCDEV_RC006_FILE_DOWNLOAD

/********************************************************************
* svc_dev_ibc_proc_msg_file_download_start --  文件开始下载命令处理
*
* PARAMETERS - As follow:
*
*		data -- 输入消息数据		
*		dataLen -- 输入消息包的长度，字节数	 	
*		pAck -- 返回结果数据	
*		bufLen -- 返回结果输入长度，字节数
*		pAckLen	-- 输出查询结果长度
*		pExrsp	-- 输出执行结果		
*
* RETURNS:
*		OK,			
*		ERROR,		
*
* EXAMPLE:
* ...
*/
LOCAL STATUS svc_dev_ibc_proc_msg_file_download_start(const OTP_UINT8 *pData, OTP_UINT32 dataLen, 
				OTP_UINT8 *pAck, OTP_UINT32 bufLen,OTP_UINT32 *pAckLen,OTP_UINT8 *pExrsp)
{
	ibc_payload_svcfile_manage *pFileManage =NULL;
	ibc_payload_svcfile_manage_ack *pFileManageAck =NULL;	
	ibc_payload_svcfile_manage_start_ack *pStartAckInfo =NULL;
/*	ibc_payload_svcfile_manage_loaddata_start_info *pStartInfo =NULL;*/
	OTP_UINT16 DeviceType = 0;
	OTP_UINT16 HexBinType = 0;	
	
	NO_USE(dataLen);
	NO_USE(pExrsp);
	
	/*参数检查*/

	/*处理头部*/	
	pFileManage = (ibc_payload_svcfile_manage *)pData;	
	pFileManageAck = (ibc_payload_svcfile_manage_ack *)pAck;
	
	/*根据协议，MCU程序可以不判断文件长度和文件名*/
/*	pStartInfo =(ibc_payload_svcfile_manage_loaddata_start_info *)pFileManage->data;*/
	/*判断文件名是否相符*/

	/*组织应答*/
	pFileManageAck->reserve =IBC_CMDACK_RESERVE;
	pFileManageAck->commandack =pFileManage->command;
	pStartAckInfo =(ibc_payload_svcfile_manage_start_ack *)pFileManageAck->data;	
	pStartAckInfo->sessionID =  FILE_DOWNLOAD_SESSION_ID;
	/*判断文件类型，决定板间通讯的最大长度*/
	if (pFileManage->fileType ==IBC_FILE_TYPE_FPGAUPDATE)
	{
/*lint -save -e778*/
		pStartAckInfo->ibcMaxLen = ntohs(FILE_DOWNLOAD_FPGA_IBC_MAX_LEN);
/*lint -restore*/
	}
	else if (pFileManage->fileType ==IBC_FILE_TYPE_MCUUPDATE)
	{
		pStartAckInfo->ibcMaxLen = ntohs(FILE_DOWNLOAD_MCU_IBC_MAX_LEN);
	}
	/*文件长度*/
/*lint -save -e572*/
	pStartAckInfo->fileLen = ntohl(FILE_DOWNLOAD_FILE_MAX_LEN);
/*lint -restore*/
		
	*pAckLen = sizeof(*pFileManageAck) + sizeof(*pStartAckInfo);
	
	if(*pAckLen > bufLen)
	{

		ASSERT(0);
		return ERROR;
	}

	/*得到文件类型*/
	HexBinType =(OTP_UINT16)IBC_BIN_FILE;
	/*得到设备类型，不支持的文件类型将返回错误*/
	if (pFileManage->fileType ==IBC_FILE_TYPE_MCUUPDATE)
	{
		DeviceType =(OTP_UINT16)IBC_MCU_DEVICE;
	}
	else if (pFileManage->fileType ==IBC_FILE_TYPE_FPGAUPDATE)
	{
		DeviceType =(OTP_UINT16)IBC_FPGA_DEVICE;
	}	
	else
	{
		g_ibc_filemanege_global_info.QueryResult =(OTP_UINT8)IBC_FILE_RESULT_UNSUCCESS;		

		ASSERT(0);
		return ERROR;	
	}

	/*调用文件下载处理函数*/
	if (OK !=g_file_downlaod_process_func(HexBinType,DeviceType,(OTP_UINT16)pFileManage->command,NULL,0))
	{
		g_ibc_filemanege_global_info.QueryResult =(OTP_UINT8)IBC_FILE_RESULT_WR_FLASH_ERROR;		

		ASSERT(0);
		return ERROR;	
	}

	/*文件下载相关变量的清0*/
	memset(&g_ibc_filemanege_global_info,0,sizeof(g_ibc_filemanege_global_info));
	
	/*序号累加*/
	g_ibc_filemanege_global_info.serialNumber =1;		
	/*保存文件类型*/
	g_ibc_filemanege_global_info.FileType =pFileManage->fileType;
	g_ibc_filemanege_global_info.QueryResult =(OTP_UINT8)IBC_FILE_RESULT_SUCCESS;
	
	return OK;
}


/********************************************************************
* svc_dev_ibc_proc_msg_file_downloading --  文件下载过程中命令处理
*
* PARAMETERS - As follow:
*
*		data -- 输入消息数据		
*		dataLen -- 输入消息包的长度，字节数	 	
*		pAck -- 返回结果数据	
*		bufLen -- 返回结果输入长度，字节数
*		pAckLen	-- 输出查询结果长度
*		pExrsp	-- 输出执行结果		
*
* RETURNS:
*		OK,			
*		ERROR,		
*
* EXAMPLE:
* ...
*/
LOCAL STATUS svc_dev_ibc_proc_msg_file_downloading(const OTP_UINT8 *pData, OTP_UINT32 dataLen, 
				OTP_UINT8 *pAck, OTP_UINT32 bufLen,OTP_UINT32 *pAckLen,OTP_UINT8 *pExrsp)
{
/*	OTP_UINT8 crc8_result=0;
 	OTP_UINT8 crc8_result_test=0;
  	OTP_UINT16 crc8_result_len=0;
  	OTP_UINT8 FileAddrFlag= 0;		
	OTP_UINT32 lasttime = 0, nowtime = 0;		   */
	OTP_UINT32 infolen = 0;	
	OTP_UINT16 len_value = 0;	
	ibc_payload_svcfile_manage *pFileManage =NULL;
	ibc_payload_svcfile_manage_ack *pFileManageAck =NULL;	
	ibc_payload_svcfile_manage_loaddata *ploadInfo =NULL;
	ibc_payload_svcfile_manage_mcu_loaddata *pmculoadinfo =NULL;
	OTP_UINT16 DeviceType = 0;
	OTP_UINT16 HexBinType = 0;	
	
	NO_USE(dataLen);
	NO_USE(pExrsp);
	
	/*参数检查*/

	/*处理头部*/	
	pFileManage = (ibc_payload_svcfile_manage *)pData;	
	pFileManageAck = (ibc_payload_svcfile_manage_ack *)pAck;

	/*判断文件类型与存储的是否一致*/
	if (pFileManage->fileType !=g_ibc_filemanege_global_info.FileType)
	{
		g_ibc_filemanege_global_info.QueryResult =(OTP_UINT8)IBC_FILE_RESULT_UNSUCCESS;		

		ASSERT(0);
		return ERROR;
	}
	/*得到下载文件的指针*/
	ploadInfo =(ibc_payload_svcfile_manage_loaddata *)pFileManage->data;	
	/*判断sessionID是否一致*/
	if (ploadInfo->sessionID !=FILE_DOWNLOAD_SESSION_ID)
	{
		g_ibc_filemanege_global_info.QueryResult =(OTP_UINT8)IBC_FILE_RESULT_SESSIONID_ERROR;		

		ASSERT(0);
		return ERROR;		
	}
/*wuruofeng 200905 对序列号判断重新处理*/
	/*判断序列号是否一致*/
	if (ntohs(ploadInfo->serialNumber) > g_ibc_filemanege_global_info.serialNumber)
	{
/*OTP_TRACE("serial Number:%02x %02x"NEWLINE,ntohs(ploadInfo->serialNumber),g_ibc_filemanege_global_info.serialNumber);
*/
		g_ibc_filemanege_global_info.QueryResult =(OTP_UINT8)IBC_FILE_RESULT_NUMBER_ERROR;		

		ASSERT(0);
		
		return ERROR;		
	}
	else if(ntohs(ploadInfo->serialNumber) == g_ibc_filemanege_global_info.serialNumber)
	{
		/*得到文件类型*/
		HexBinType =(OTP_UINT16)IBC_BIN_FILE;
		/*得到设备类型*/
		if (pFileManage->fileType ==IBC_FILE_TYPE_MCUUPDATE)
		{
			DeviceType =(OTP_UINT16)IBC_MCU_DEVICE;
		}
		else if (pFileManage->fileType ==IBC_FILE_TYPE_FPGAUPDATE)
		{
			DeviceType =(OTP_UINT16)IBC_FPGA_DEVICE;
		}	
		else
		{
			g_ibc_filemanege_global_info.QueryResult =(OTP_UINT8)IBC_FILE_RESULT_UNSUCCESS;		

			ASSERT(0);
			return ERROR;	
		}

		/*判断数据长度是否符合要求*/
		len_value =ntohs(ploadInfo->dataLen );
		if (DeviceType ==(OTP_UINT16)IBC_MCU_DEVICE)
		{
			if ((len_value <=FILE_DOWNLOAD_DATA_MIN_LEN) || (len_value>FILE_DOWNLOAD_MCU_IBC_MAX_LEN))
			{
				g_ibc_filemanege_global_info.QueryResult =(OTP_UINT8)IBC_FILE_RESULT_UNSUCCESS;		

				ASSERT(0);
				return ERROR;		
			}
		}
		else if (DeviceType ==(OTP_UINT16)IBC_FPGA_DEVICE)
		{
			if (len_value >FILE_DOWNLOAD_FPGA_IBC_MAX_LEN)
			{
				g_ibc_filemanege_global_info.QueryResult =(OTP_UINT8)IBC_FILE_RESULT_UNSUCCESS;		

				ASSERT(0);
				return ERROR;		
			}
		}

		/*进行CRC8校验*/
	/*	crc8_result_len =ploadInfo->dataLen;

		crc8_result =ploadInfo->info[crc8_result_len];
		crc8_result_test =crc_8(ploadInfo->info,(ploadInfo->dataLen));


		if (crc8_result !=crc_8(ploadInfo->info,(ploadInfo->dataLen)))
		{
			g_ibc_filemanege_global_info.QueryResult =(OTP_UINT8)IBC_FILE_RESULT_CRC8_ERROR;		
			return ERROR;	
		}

lasttime= tmr_get_time(); 	 */
		/*下载地址范围判断，符合地址范围调用文件下载函数，不符合地址范围的不处理*/
		if (DeviceType ==(OTP_UINT16)IBC_MCU_DEVICE)
		{
			pmculoadinfo =(ibc_payload_svcfile_manage_mcu_loaddata*)ploadInfo->info;
			if ((ntohl(pmculoadinfo->address)) <FILE_DOWNLOAD_FLASH_ADDRESS)
			{
				/*不需要写入FLASH的程序文件*/
	/*			FileAddrFlag =0;*/
			}
			else
			{
				/*获得净核数据指针和长度*/
				infolen =len_value-sizeof(*pmculoadinfo);
				/*调用文件下载处理函数*/
				if (OK !=g_file_downlaod_process_func(HexBinType,DeviceType,(OTP_UINT16)pFileManage->command,pmculoadinfo->info,infolen))
				{
					g_ibc_filemanege_global_info.QueryResult =(OTP_UINT8)IBC_FILE_RESULT_WR_FLASH_ERROR;		

					ASSERT(0);
					return ERROR;	
				}	
			}
		}
		else if (DeviceType ==(OTP_UINT16)IBC_FPGA_DEVICE)
		{
			/*获得净核数据指针和长度*/
			infolen =len_value;
			/*调用文件下载处理函数*/
			if (OK !=g_file_downlaod_process_func(HexBinType,DeviceType,(OTP_UINT16)pFileManage->command,ploadInfo->info,infolen))
			{
				g_ibc_filemanege_global_info.QueryResult =(OTP_UINT8)IBC_FILE_RESULT_WR_FLASH_ERROR;		

				ASSERT(0);
				return ERROR;	
			}					
		}
		
/*nowtime= tmr_get_time(); 
OTP_TRACE("write flash last , lasttime = %u, nowtime = %u, delta = %u\r\n", lasttime, nowtime, nowtime-lasttime);
*/
		/*序号累加*/
		g_ibc_filemanege_global_info.serialNumber++;
	}
	else
	{/*接收序列号小于预期序列号，可能是对端没有收到响应报文
		做的重传处理，不处理直接应答ok即可*/
/*OTP_TRACE("serial Number:%02x %02x"NEWLINE,ntohs(ploadInfo->serialNumber),g_ibc_filemanege_global_info.serialNumber);
*/
	}

	/*组织应答*/
	pFileManageAck->reserve =IBC_CMDACK_RESERVE;
	pFileManageAck->commandack =pFileManage->command;
	pFileManageAck->data[0] =  FILE_DOWNLOAD_SESSION_ID;
		
	*pAckLen = sizeof(*pFileManageAck)+1;
	
	if(*pAckLen > bufLen)
	{

		ASSERT(0);
		return ERROR;
	}

	return OK;
}

/********************************************************************
* svc_dev_ibc_proc_msg_file_query_result --  文件下载结果查询
*
* PARAMETERS - As follow:
*
*		data -- 输入消息数据		
*		dataLen -- 输入消息包的长度，字节数	 	
*		pAck -- 返回结果数据	
*		bufLen -- 返回结果输入长度，字节数
*		pAckLen	-- 输出查询结果长度
*		pExrsp	-- 输出执行结果		
*
* RETURNS:
*		OK,			
*		ERROR,		
*
* EXAMPLE:
* ...
*/
LOCAL STATUS svc_dev_ibc_proc_msg_file_query_result(const OTP_UINT8 *pData, OTP_UINT32 dataLen, 
				OTP_UINT8 *pAck, OTP_UINT32 bufLen,OTP_UINT32 *pAckLen,OTP_UINT8 *pExrsp)
{
	ibc_payload_svcfile_manage *pFileManage =NULL;
	ibc_payload_svcfile_manage_ack *pFileManageAck =NULL;	

	NO_USE(dataLen);
	NO_USE(pExrsp);
	
	/*参数检查*/
	
	/*处理头部*/	
	pFileManage = (ibc_payload_svcfile_manage *)pData;	
	pFileManageAck = (ibc_payload_svcfile_manage_ack *)pAck;

	/*暂不作文件类型检查*/
	
	/*组织应答*/
	pFileManageAck->reserve =IBC_CMDACK_RESERVE;
	pFileManageAck->commandack =pFileManage->command;
	pFileManageAck->data[0] =  (OTP_UINT8)FILE_DOWNLOAD_SESSION_ID;
	pFileManageAck->data[1] =  g_ibc_filemanege_global_info.QueryResult ;	
		
	*pAckLen = sizeof(*pFileManageAck) + 2;
	
	if(*pAckLen > bufLen)
	{
		ASSERT(0);
		return ERROR;
	}	
	
	return OK;
}


/********************************************************************
* svcdev_proc_file_manage -- 处理局端发来的文件操作命令函数
*
* PARAMETERS - As follow:
*		arg	--		void类型指针
*		msg --		原始消息包。如果需要直接处理消息包可以用它。
*					当返回值为OK时必须释放，否则不能释放。
*		prid --		接收到消息的远端设备标识数组
*		opcode --	操作码类型
*		data --	具体消息数据("扩展协议头"后面到"校验和"之前)，不能释放。
*		datalen --	data中有效数据的长度
*		pAck	-- 返回结果内容指针
*		bufLen -- 返回结果输入长度，字节数	
*
* RETURNS:
*		OK,			
*		ERROR,		
*
* EXAMPLE:
* ...
*/
STATUS svcdev_proc_file_manage(const  OTP_VOID *arg, IBC_MSG msg,const  rdev_rid* prid,
						OTP_UINT8 opcode,const OTP_UINT8 *pData,OTP_UINT32 dataLen, OTP_UINT8 *pAck,
						OTP_UINT32 bufLen)
{
	STATUS ret = ERROR;
	OTP_UINT32 acklen = 0;
	OTP_UINT8 exrsp = IBC_EXRSP_OK;	
	ibc_payload_svcfile_manage *pFileManage =NULL;
/*	ibc_payload_svcfile_manage_ack *pFileManageAck =NULL;	*/

	NO_USE(arg);
	NO_USE(msg);
	NO_USE(prid);
	NO_USE(opcode);

	/*入参检查*/
	if(pAck == NULL)
	{
		return ERROR;
	}	

	/*(OTP_VOID)cmf_priority_set(SVC_DEV_VCG_NUM,TRUE,FALSE);		   */

	memset(pAck,0,bufLen);	
	
	/*处理头部*/	
	pFileManage = (ibc_payload_svcfile_manage *)pData;	
/*	pFileManageAck = (ibc_payload_svcfile_manage_ack *)pAck;*/
	
	/*板卡类型检查*/
	
	/*命令检查*/
	if ((pFileManage->command >IBC_FILE_CMD_QUERY_RESULT) || (pFileManage->command==IBC_FILE_CMD_NULL))
	{
		g_ibc_filemanege_global_info.QueryResult =(OTP_UINT8)IBC_FILE_RESULT_UNSUCCESS;	


		ASSERT(0);
		return ERROR;
	}
	/*文件类型检查*/
	if ((pFileManage->fileType >IBC_FILE_TYPE_MCUUPDATE) || (pFileManage->fileType==IBC_FILE_TYPE_NULL))
	{
		/*无效的文件类型*/
		g_ibc_filemanege_global_info.QueryResult =(OTP_UINT8)IBC_FILE_RESULT_FILE_TYPE_ERROR;	

		ASSERT(0);
		return ERROR;
	}

	/*判断命令字*/
	switch(pFileManage->command)
	{
		case IBC_FILE_CMD_DOWNLOAD_START: /* 文件开始下载*/
			ret = svc_dev_ibc_proc_msg_file_download_start(pData,dataLen, pAck, bufLen, &acklen, &exrsp);	
			break;
		case IBC_FILE_CMD_DOWNLOADING: /* 文件下载过程中*/
			ret = svc_dev_ibc_proc_msg_file_downloading(pData,dataLen, pAck, bufLen, &acklen, &exrsp);
			break;
		case IBC_FILE_CMD_DOWNLOAD_END: /* 文件下载结束*/
			ret = svc_dev_ibc_proc_msg_file_downloading(pData,dataLen, pAck, bufLen, &acklen, &exrsp);
			break;
		case IBC_FILE_CMD_QUERY_RESULT: /* 文件查询结果*/
			ret = svc_dev_ibc_proc_msg_file_query_result(pData,dataLen, pAck, bufLen, &acklen, &exrsp);
			break;
		default:
			exrsp = IBC_EXRSP_ERROR_OPCODE;
			break;
	}

	if(ret != OK)
	{
		if(IBC_EXRSP_OK == exrsp)
		{
			/*如果具体失败原因没有填，在这里填一下*/
			exrsp = IBC_EXRSP_OP_ERROR;
		}
		acklen = 0;
	}
	/*发送消息*/	
	if( ibcadp_send(arg,msg,prid,exrsp,(OTP_UINT8*)pAck, acklen) != OK )
	{
		ASSERT(0);
		return ERROR;
	}

	return ret;

}

/*业务盘RC006文件下载初始化函数*/
OTP_VOID svcdev_rc006_file_manage(void)
{

	memset(&g_ibc_filemanege_global_info,0,sizeof(g_ibc_filemanege_global_info));
	g_file_downlaod_process_func =file_downloading;

}

#endif

/*panwei 2012-7-19*/
/*处理网管盘来的派生设备握手信息
	输入参数:
	compareFlag,	是否要进行派生产品名称的比对再响应网管帧。
		arg,		void类型指针	
		msg,		原始消息包。如果需要直接处理消息包可以用它。
					当返回值为OK时必须释放，否则不能释放。
		prid,		接收到消息的远端设备标识数组
		opcode,		操作码类型
		data,		具体消息数据("板卡类型"后面到"校验和"之前的数据，含命令字和命令块等业务信息)，
					不能释放。
		datalen,	data中有效数据的长度
	返回值:
		OK,			本函数消化了msg消息，在返回前已经释放了msg,IBC适配层模块不能再释放该消息
		ERROR,		本函数没有消化msg消息，在返回后由IBC适配层模块释放msg消息
*/
LOCAL STATUS svcdev_proc_derive_handshake(BOOL compareFlag,OTP_VOID *arg, IBC_MSG msg,
								const rdev_rid* prid,OTP_UINT8 opcode,const OTP_UINT8 *data,
								OTP_UINT32 datalen, OTP_UINT8 *pAck, OTP_UINT32 acklen)
{
	STATUS ret = ERROR;
	OTP_UINT8 exrsp = IBC_EXRSP_OK;
	svcdev_derive_query_info *pQuery = NULL;			/*定义派生握手操作发送帧*/
	svcdev_derive_query_ack_info *pQueryAck = NULL;		/*定义派生握手操作响应帧*/
	OTP_UINT8 index = 0;

	NO_USE(datalen);
	
	if(IBC_OPCODE_DERIVE_HANDSHAKE != opcode)
	{/*非握手操作命令码，直接返回失败*/
		ASSERT(0);
		return ERROR;
	}

	if(NULL == pAck)
	{/*上层申请的空间是空的话，不再进行下步处理*/
		ASSERT(0);
		return ERROR;
	}

	/*返回数据区清零，并进行报文填充*/
	memset(pAck,0,acklen);
	pQueryAck =(svcdev_derive_query_ack_info *)pAck;
	pQueryAck->devt =  htons(svc_get_devtype(arg));
	pQueryAck->resByte = 0x80;
	/*计算长度*/
	for(index = 0; index < PRO_NAME_LENGTH; index++)
	{
		/*panwei 2012-10-18 bugID:ITS00049192*/
	    if((g_product_name[index] > 0x7f) || (g_product_name[index] < 0x20))
	    {
	        break;
	    }
	}
	if(index >= PRO_NAME_LENGTH)
	{
		ASSERT(0);
		return ERROR;
	}
	pQueryAck->proNameLen = index;
	memcpy(pQueryAck->proName, &g_product_name, index);
		
	if(compareFlag)
	{/*需要比对才能发送响应帧*/		
		if(NULL == data)
		{
			ASSERT(0);
			return ERROR;			
		}
		pQuery = (svcdev_derive_query_info *)data;			/*发送帧的指向*/

		if(DERIVE_PRODUCT_NAME_MAXLEN < pQuery->proNameLen)
		{/*派生名称（最大50字节)*/
			ASSERT(0);
			return ERROR;			
		}
		/*对比派生名称长度是否一致*/
		if(pQuery->proNameLen == pQueryAck->proNameLen)
		{
			for(index = 0; index < pQuery->proNameLen; index++)
			{/*派生握手操作发送帧中的派生名称与本产品的派生名称进行字节比对*/
				if(pQuery->proName[index] != pQueryAck->proName[index])
				{
					break;
				}
			}

			if(index == pQuery->proNameLen)
			{/*比较过程中，都是匹配的*/
				g_deriveHandshakeFlag = TRUE;		/*可以进行一次中断查询或者是一次反向配置查询了*/
				ret = OK;
			}
		}
	}
	
	if(ERROR == ret)
	{/*匹配失败*/
		exrsp = IBC_EXRSP_ERROR_NOT_MATCH;
	}

	/*响应净荷的长度*/
	acklen = sizeof(svcdev_derive_query_ack_info) + pQueryAck->proNameLen;
	
	/*发送应答消息*/	
	if( ibcadp_send(arg,msg,prid,exrsp,(OTP_UINT8*)pAck, acklen) != OK )
	{
		ASSERT(0);
		return ERROR;
	}

	return ret;
}

/*
	业务盘上的业务模块处理从网管盘发来的数据的函数。
	输入参数:
		arg,		void类型指针
		msg,		原始消息包。如果需要直接处理消息包可以用它。
					当返回值为OK时必须释放，否则不能释放。
		slot,	 	接收到的消息的源槽位号
		prid,		接收到消息的远端设备标识数组
		opcode,		操作码类型
		data,		具体消息数据，板间通信的净荷部分("操作码类型"后面到"校验和"之前的数据)，
					不能释放。
		datalen,	data中有效数据的长度
	返回值:
		OK,			本函数消化了msg消息，在返回前已经释放了msg,IBC适配层模块不能再释放该消息
		ERROR,		本函数没有消化msg消息，在返回后由IBC适配层模块释放msg消息
*/

STATUS svcdev_proc_nms_msg(OTP_VOID *arg, IBC_MSG msg,const rdev_rid* prid,OTP_UINT8 opcode,
						const OTP_UINT8 *data,OTP_UINT32 datalen, OTP_UINT8 *pack, OTP_UINT32 acklen)
{
	STATUS ret=ERROR;

	/* 当还没有进入工作状态的时候，查询和远端设备在位查询消息都不执行 */
	if( g_svcdev_startup_stage != svcdevs_working )
	{
		if(opcode==IBC_OPCODE_QUERY || opcode==IBC_OPCODE_RDEV_PRESENCE)
		{
			/* 不支持 */
			return svcdev_proc_unsupport_msg(arg, msg,prid,opcode,data,datalen);
		}
	}


	/* 远端设备在位查询和发送给远端的消息都由远端模块来处理 */
	if( opcode == IBC_OPCODE_RDEV_PRESENCE 	
		|| ( prid!= NULL && prid->hop > 0) )
	{
		/* 处理远端消息 */
		#ifdef INCLUDE_RDEV
		/*ret = svc_rdev_NMS_msg_proc(arg, msg,prid,opcode,data,datalen, pack, acklen);*/
        #else
		/* 不包含远端模块的时候，也要处理对远端的查询，局端直接返回SKIP */
		return svcdev_proc_unsupport_msg(arg, msg,prid,opcode,data,datalen);
        #endif
	}
	else
	{
		/* 处理局端消息 */
		switch(opcode)
		{
			case IBC_OPCODE_QUERY:
			case IBC_OPCODE_CONFIG:
			case IBC_OPCODE_COMMAND:
			case IBC_OPCODE_QUERY_VER:
			case IBC_OPCODE_QUERY_MEMINFO:
			case IBC_OPCODE_MODIFY_MEMINFO:
			case IBC_OPCODE_EXT_CONFIG:
				/*交给业务模块来处理,用户程序均在此函数中调用*/
				ret = svc_NMS_msg_proc(arg,msg,prid,opcode,data,datalen,pack,acklen);
				break;
			case IBC_OPCODE_REVERSE_CFG:/*反向配置查询*/
			#if 0
				if(g_deriveHandshakeFlag)
				{
					if(OK == strncmp(SLT_NAME, g_product_name, strlen(SLT_NAME)))
					{
					    g_deriveHandshakeFlag = FALSE;
					}
					ret = svcdev_proc_reverse_cfg(arg,msg, prid,opcode,data,datalen,pack,acklen);
				}
			#endif
				ret = svcdev_proc_reverse_cfg(arg,msg, prid,opcode,data,datalen,pack,acklen);
				break;
			case IBC_OPCODE_RESET_HARD:
			case IBC_OPCODE_RESET_SOFT:
				/*业务盘重启*/
				ret = svcdev_proc_reset_hard(arg, msg,prid,opcode,data,datalen);
				break;	
			case IBC_OPCODE_HEART_BEAT:
				/*业务盘心跳*/
				ret=svcdev_proc_heard_beat(arg,msg,prid,opcode,data,datalen);
				break;	
			case IBC_OPCODE_CONFIG_DONE:
				ret = svcdev_proc_config_done(arg,msg,prid,opcode,data,datalen);
				break;
			case IBC_OPCODE_QUERY_DEVINFO:
				ret = svcdev_proc_devinfo_msg(arg, msg,prid,opcode,data,datalen);
				break;	
			case IBC_OPCODE_INTERRUPT:/*中断响应*/
			#if 0
				if(g_deriveHandshakeFlag)
				{
					if(OK == strncmp(RP3000H_NAME, g_product_name, strlen(RP3000H_NAME)))
					{
					    g_deriveHandshakeFlag = FALSE;
					}
					ret = svcdev_proc_interrupt(arg, msg,prid,opcode,data,datalen,pack,acklen);						
				}
				else
				{
					/*panwei 2012-7-20 没有握手完成则清除中断*/
				    if(g_svc_intflag != 0)
					{
						/*清硬件中断*/
						g_svc_intflag = 0;
						(OTP_VOID)CLEAR_HARDWARE_INT;
					}
				}
			#endif
				ret = svcdev_proc_interrupt(arg, msg,prid,opcode,data,datalen,pack,acklen);	
				break;					
			case IBC_OPCODE_LOOPBACK_CANCEL:
				/*环回在IBC适配层就应该处理掉了*/
				break;		
				
#ifdef INCLUDE_SVCDEV_RC006_FILE_DOWNLOAD				
			case IBC_OPCODE_SVC_FILE_MANAGE:/*业务盘文件操作命令*/
				ret = svcdev_proc_file_manage(arg,msg,prid,opcode,data,datalen,pack,acklen);
				break;		
#endif			

#ifdef INCLUDE_PRODUCT_MSG_FORMAT
			/*查询产品信息*/    
			case IBC_OPCODE_QUERY_MFINFO:
				ret = svcdev_proc_pdt_query(arg,msg,prid,opcode,data,datalen,pack,acklen);
				break;
#endif
#if 1
			case IBC_OPCODE_DERIVE_HANDSHAKE:				
				ret = svcdev_proc_derive_handshake(TRUE,arg,msg,prid,opcode,data,datalen,pack,acklen);
				break;		
#endif
			case IBC_OPCODE_DEV_DEBUG:
				ret = svcdev_proc_dev_debug(arg,msg,prid,opcode,data,datalen,pack,acklen);
				break;
			case IBC_OPCODE_BANDWIDTH_CFG:
			case IBC_OPCODE_QUERY_BANDWIDTH:
			case IBC_OPCODE_DXCSWITCH:	
			case IBC_OPCODE_REQ_CONFIG_SYNC:
			case IBC_OPCODE_CONIFG_SYNC:
			case IBC_OPCODE_LOOPBACK_SET:
			case IBC_OPCODE_ADD_DEVICEID:
			case IBC_OPCODE_DEL_DEVICEID:
			case IBC_OPCODE_QUERY_CPU_MEM:
			case IBC_OPCODE_SAVE_STARTUP_CONFIG:
			case IBC_OPCODE_ERASE_STARTUP_CONFIG:
			case IBC_OPCODE_SYS_CMD:

			default:
				/*业务盘暂时不支持*/			
				ret = svcdev_proc_unsupport_msg(arg, msg,prid,opcode,data,datalen);
				break;
		}
	}
	return ret;	
}



/*业务盘初始化函数*/
OTP_VOID svcdev_init_rc006(void)
{

	/*中断表初始化*/
	(OTP_VOID)svcdev_int_init();
	
	/*svc_init_detail_version();	*/
	
	/*初始化文件下载*/
#ifdef  INCLUDE_SVCDEV_RC006_FILE_DOWNLOAD
	svcdev_rc006_file_manage();
#endif

#if 0	
	/* 约定好了在svc_init函数中必须初始化下面这些全局变量*/
	if(g_local_svc_devtype == 0)  /*wangzaizhong 20090818 不再对g_local_svc_slot进行判断*/
	{
		return;
	}
#endif

	/*消息处理函数*/
	g_ibcadp_proc_nms_msg = svcdev_proc_nms_msg;

	/*触发中断，如果在configdone来到之后，又收到了查询中断的消息*/
	(OTP_VOID)svcdev_trigger_int_cfgreq();

	/*开始等待configdone*/
	g_svc_config_done_htmr = tmr_create(SVCDEV_CONFIG_DONE_WAITTIME, TMR_LOOP, svcdev_configdone_timeout, 0);

	if(g_svc_config_done_htmr == TMR_INVALID_HTMR)
	{
		return;
	}

	return;
}

/*lint -restore*/



#endif
