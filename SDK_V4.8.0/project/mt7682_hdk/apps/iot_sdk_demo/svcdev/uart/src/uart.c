/****************************************************************
	Copyright(C), 1999-2004 Raisecom, Inc.
	filename: uart.c，串口驱动函数核心文件
	Author	: qiaoqiangguo
	version	: 1.0
	date	: 2008/6/21
	Others	:
        THIS DOCUMENT IS GENERATED BY TORNADO TOOLS refgen.exe
        EXAMPLE:
        ->torVars.bat
        ->refgen -mg -out doc uart.c
        ->cd doc
        ->htmllink
*****************************************************************/


#include "otpconfig.h"

#if (defined(INCLUDE_UART1) || defined(INCLUDE_UART2)|| defined(INCLUDE_UART3))

#include "string.h"
#include "macro_common.h"
#include "stm32f10x.h"
#include "tmr.h"
#include "uart.h"
#include "svc_dev.h"

#ifdef INCLUDE_IBC_RC002
#include "toolkit.h"
#include "ibc_rc002.h"
#endif

#ifdef  INCLUDE_X_MODEM_COMM
#include "x_modem.h"
#endif 

#ifdef INCLUDE_OPTTYPE
#include "trace.h"
#endif

/*调用产品信息下载接收函数*/
#ifdef INCLUDE_PRODUCT_MSG_COMM_PRTCL
/*使能在CONSEL串口处理产品信息下载协议*/
#include "pdt_msg_com_ptl.h"

#ifdef INCLUDE_PRODUCT_MSG_COMM_PRTCL_CONSEL
#include "trace.h"
extern trace_msg_send g_msg_msg_send;		/*consol发送函数*/
#else
#ifdef INCLUDE_PRODUCT_MSG_COMM_PRTCL_RC006
#include "ibc.h"
//extern xxx_msg_send g_sync_send_func;		/*串口1发送函数*/
#endif
#endif
#endif
/*UART相关的寄存器*/
USART_TypeDef *UART_REG[UARTIDMAX] = {USART1,USART2,USART3};


/*lint -save -e818*/


/******************************************************************************************
*uart_init		--串口初始化函数
*--
*Input:
*	uid		--串口号，合法值为0或者1
*	pcfg	--串口的初始化参数
*Output:
*	无
*Return:
*	OK/ERROR	表示执行成功与否
*
*/
STATUS uart_port_init(OTP_UINT8 uid,const  uart_config_struct *pcfg)
{
	OTP_UINT32	uart_clock = 0;
	OTP_UINT32	integer= 0;	
	OTP_UINT32	fraction = 0;
	OTP_UINT32	tmpreg = 0;
	OTP_UINT8	port[UARTIDMAX]={UART1_PORT,UART2_PORT,UART3_PORT};
	OTP_UINT8	rx_pin[UARTIDMAX]={UART1_RXD_PIN,UART2_RXD_PIN,UART3_RXD_PIN};
	OTP_UINT8	tx_pin[UARTIDMAX]={UART1_TXD_PIN,UART2_TXD_PIN,UART3_TXD_PIN};	
	
	/*参数检查*/
	if(!UART_VALID_UID(uid))
	{
		MCU_EXC_ERROR;
		return ERROR;
	}
	
	if(!UART_VALID_PCFG(pcfg))
	{
		MCU_EXC_ERROR;
		return ERROR;
	}

	/*初始化指针数组*/
	if(uid == UART1_ID)
	{		
		/*设置Remap值，AFIO_MAPR寄存器*/		
#if (UART1_REMAP_MODE == 1)
		AFIO->MAPR |= AFIO_MAPR_USART1_REMAP;
#endif
	}
	else if(uid == UART2_ID)
	{		
		/*设置Remap值，AFIO_MAPR寄存器*/		
#if (UART2_REMAP_MODE == 1)
		AFIO->MAPR |= AFIO_MAPR_USART2_REMAP;
#endif	
	}
	else
	{
		/*设置Remap值，AFIO_MAPR寄存器*/		
#if (UART3_REMAP_MODE == 1)
		AFIO->MAPR |= AFIO_MAPR_USART3_REMAP_0;
#elif (UART3_REMAP_MODE == 3)
		AFIO->MAPR |= AFIO_MAPR_USART3_REMAP;
#endif
	}	

	/* Configure USART Rx as input floating*/
	IODIR_X(port[uid], rx_pin[uid], GPIO_Mode_IN_FLOATING);

	/* Configure USART Tx as alternate function push-pull*/	
	IODIR_X(port[uid], tx_pin[uid], GPIO_Mode_Out_AF_PP_Max_50MHz);

	/*设置停止位,默认1个停止位*/
	UXCR2(UART_REG[uid]) &= 0xC0FF;
	if(pcfg->stopb == UART_STOPB_2BIT)
	{
		UXCR2(UART_REG[uid]) |= USART_CR2_STOP_1;
	}
	
	/*设置数据位,默认1 Start bit, 8 Data bits*/
	UXCR1(UART_REG[uid]) &= 0xC000;
	if(pcfg->datab == UART_DATAB_9BIT)
	{
		UXCR1(UART_REG[uid]) |= USART_CR1_M;
	}
	
	/*设置校验位*/
	if(pcfg->parity == UART_PARITY_NONE)
	{
		UXCR1(UART_REG[uid]) &= (~USART_CR1_PCE);
	}
	else if(pcfg->parity == UART_PARITY_EVEN)
	{
		UXCR1(UART_REG[uid]) |= USART_CR1_PCE;	
		UXCR1(UART_REG[uid]) &= (~USART_CR1_PS);
	}
	else if(pcfg->parity == UART_PARITY_ODD)
	{
		UXCR1(UART_REG[uid]) |= USART_CR1_PCE;	
		UXCR1(UART_REG[uid]) |= USART_CR1_PS;
	}

	/*设置发送接收使能*/
	UXCR1(UART_REG[uid]) |= (USART_CR1_TE | USART_CR1_RE);

	/* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
	UXCR3(UART_REG[uid]) &= (~(USART_CR3_CTSE | USART_CR3_RTSE));

	/*设置波特率*/	
 	if(uid == UART1_ID)
 	{
		uart_clock = SystemFrequency_APB2Clk;
	}
	else
	{
		uart_clock = SystemFrequency_APB1Clk;
	}
  	integer = (0x19 * uart_clock) /(0x04 * (pcfg->baud));
	tmpreg = (integer/100)<<0x04;
	fraction = integer  - (100 *(tmpreg>>0x04));
	tmpreg |= (((fraction*0x10)+0x32)/0x64)&((OTP_UINT8)0x0F);
	UXBRR(UART_REG[uid]) = tmpreg;
	
	/* Enable USART Receive  interrupts and Transmit complete interrupts*/
  	UXCR1(UART_REG[uid]) |= USART_CR1_RXNEIE;	
  	UXCR1(UART_REG[uid]) |= USART_CR1_TCIE;	
  
	/* Enable the USART */
	UXCR1(UART_REG[uid]) |= USART_CR1_UE;

	return OK;
}


/****************************************************************************
* --uart_interrupt() UART0中断服务程序。
* Input:
*	uid --串口编号
*	pinfo --串口信息处理结构指针
*Output:
*	None
*Return:
*	None
*/
OTP_VOID uart_interrupt(OTP_UINT8 uid, uart_info *pinfo) 
{
	OTP_UINT32 iir = 0;
	OTP_UINT16 index = 0;
	OTP_UINT8 val =0;
	
	/*参数检查*/
	if(!UART_VALID_UID(uid))
	{
		MCU_EXC_ERROR;
		return ;
	}

	if(pinfo == NULL)
	{
		MCU_EXC_ERROR;
		return ;
	}

	iir = UXSR(UART_REG[uid]);	
	if(iir & USART_SR_RXNE)
	{/*有新数据需要接收,不管缓存区是否溢出，数据必须读出*/
		val =UXDR(UART_REG[uid]);			/*接收新数据,同时清除中断挂起*/
		if(!pinfo->rinfo.flag.bufof)
		{/*如果接收缓冲没有溢出*/
			index = pinfo->rinfo.rtbuf.pinput;
			pinfo->rinfo.rtbuf.buf[index] = val;
			index = (index+1)%UART_RCV_TEMPBUF_LEN;/*以datalen为模加index*/
			if(index == pinfo->rinfo.rtbuf.poutput)
			{/*接收的速度大于处理的速度了*/
				MCU_EXC_ERROR;
				pinfo->rinfo.flag.bufof = ENABLE;/*溢出了*/
			}
			else
			{
				pinfo->rinfo.rtbuf.pinput = index;/*更新输入指针长度*/
			}
		}
	}
	
	if(iir & USART_SR_TC)
	{/*数据发送完成，可以发送新数据*/
		UXSR(UART_REG[uid]) = (~USART_SR_TC);	/*清除中断挂起*/
		if(pinfo->sinfo.poutput != pinfo->sinfo.pinput)
		{/*如果有数据需要发送*/
			index = pinfo->sinfo.poutput;
			UXDR_SET(UART_REG[uid], pinfo->sinfo.pdata[index]);/*新数据写入发送缓冲*/
			pinfo->sinfo.poutput = (index+1)%pinfo->sinfo.datalen;/*以datalen为模加index*/
		}
		else
		{/*没有数据需要发送*/
			pinfo->sinfo.sending = FALSE;
			(OTP_VOID)svc_uart_send_disable(uid);
		}
	}

	return;
}




/*******************************************************************************
*uart_rcv_process_rc002  002协议接收报文处理，按照相应的协议，对接收缓冲区的报文进行处理，并调用
*		注册的rcv处理函数；
*Input:
*	prinfo	--接收缓冲区相关信息指针；
*Output:
*	None	
*Return:
*	OK/ERROR，表示执行成功和失败
*/
LOCAL STATUS uart_rcv_process_rc002(OTP_VOID *arg, uart_rcv_info *prinfo)
{
	NO_USE(arg);
	NO_USE(prinfo);
	return OK;
}


/*******************************************************************************
*uart_rcv_process_rc004  004协议接收报文处理，按照相应的协议，对接收缓冲区的报文进行处理，并调用
*		注册的rcv处理函数；
*Input:
*	prinfo	--接收缓冲区相关信息指针；
*Output:
*	None	
*Return:
*	OK/ERROR，表示执行成功和失败
*/
LOCAL STATUS uart_rcv_process_rc004(OTP_VOID *arg, uart_rcv_info *prinfo)
{
	NO_USE(arg);
	NO_USE(prinfo);
	return OK;
}

/*******************************************************************************
*uart_rcv_process_console  console接收报文处理，按照相应的协议，对接收缓冲区的报文进行处理，并调用
*		注册的rcv处理函数；
*Input:
*	prinfo	--接收缓冲区相关信息指针；
*Output:
*	None	
*Return:
*	OK/ERROR，表示执行成功和失败
*/
LOCAL STATUS uart_rcv_process_console(OTP_VOID *arg, uart_rcv_info *prinfo)
{
#ifdef INCLUDE_CLI
	OTP_UINT8 val = 0;
	OTP_UINT32 index = 0;
	OTP_UINT32 ucnt = 0;
	
	/*参数检查*/
	if(prinfo == NULL)
	{
		MCU_EXC_ERROR;
		return ERROR;
	}

	/*20090828modify,szb*/
	if(prinfo->flag.bufof==TRUE)
	{
		prinfo->flag.bufof=FALSE;
		prinfo->rtbuf.poutput = prinfo->rtbuf.pinput;
		prinfo->rproc.outcnt = 0; 
	}

	/*看看接收暂存缓冲区当前有没有数据可以接收*/
	if(prinfo->rtbuf.poutput == prinfo->rtbuf.pinput)
	{/*没有新数据*/
		return OK;
	}

/*调用产品信息下载接收函数*/
#ifdef INCLUDE_PRODUCT_MSG_COMM_PRTCL
/*使能在CONSEL串口处理产品信息下载协议*/
#ifdef INCLUDE_PRODUCT_MSG_COMM_PRTCL_CONSEL
    /*处于Xmodem程序升级下，不处理产品信息下载协议*/
	if (XMODEM_ENABLE != xmodem_get_message_state())
	{
		/*调用产品信息下载接收函数*/
		if(OK == pdt_msg_protocol_rcv(arg, (OTP_UINT16 *)&prinfo->rtbuf.pinput, 
                                     (OTP_UINT16 *)&prinfo->rtbuf.poutput, 
                                      prinfo->rtbuf.buf, UART_RCV_TEMPBUF_LEN))
		{
			return OK;
		}
	}
#endif
#endif
	
	/*记录接收暂存缓冲区开始处理的位置*/
	index = prinfo->rtbuf.poutput;

	/*处理已经接收完毕但是还没有处理的报文内容*/
	while(index != prinfo->rtbuf.pinput)
	{
		/*获取接收缓冲区的内容*/
		val = prinfo->rtbuf.buf[index];
		prinfo->rproc.pdata[ucnt++] = val;

		/*处理下一个字符*/
		index = (index+1)%UART_RCV_TEMPBUF_LEN;
		
	}

	if(prinfo->rproc.rcv == NULL)
	{/*没有注册接收函数，报错*/
		MCU_EXC_ERROR;
		return ERROR;
	}
	if(prinfo->rproc.rcv(arg, UART_PRTTYPE_CONSOLE, prinfo->rproc.pdata, ucnt, NULL) != OK)
	{/*执行失败，报错*/
		MCU_EXC_ERROR;
	}

	/*更新输出起始指针*/
	prinfo->rtbuf.poutput = index;
	
	return OK;

#else
	NO_USE(arg);
	NO_USE(prinfo);
	return OK;
#endif	
}

/*******************************************************************************
*uart_rcv_process_rc006  006协议接收报文处理，按照相应的协议，对接收缓冲区的报文进行处理，并调用
*		注册的rcv处理函数；
*Input:
*	prinfo	--接收缓冲区相关信息指针；
*Output:
*	None	
*Return:
*	OK/ERROR，表示执行成功和失败
*/
LOCAL STATUS uart_rcv_process_rc006(OTP_VOID *arg, uart_rcv_info *prinfo)
{
#ifdef INCLUDE_IBC_RC006
	OTP_UINT8 val = 0;
	OTP_UINT32 index = 0;
	OTP_UINT32 ucnt = 0;
#ifndef	OTP_RUN_SIMPC
	OTP_UINT32 rtime = 0;
#endif
	BOOL errflag = FALSE;
	uart_rc006_verlen *pverlen = NULL;
	
	/*参数检查*/
	if(prinfo == NULL)
	{
		MCU_EXC_ERROR;
		return ERROR;
	}
	/*20090828modify,szb*/
	if(prinfo->flag.bufof==TRUE)
	{
		prinfo->flag.bufof=FALSE;
		prinfo->rtbuf.poutput = prinfo->rtbuf.pinput;
		prinfo->rproc.outcnt = 0; 
	}

	/*看看接收暂存缓冲区当前有没有数据可以接收*/
	if(prinfo->rtbuf.poutput == prinfo->rtbuf.pinput)
	{/*没有新数据*/
		return OK;
	}

#ifndef	OTP_RUN_SIMPC
	/*检查字节接收间隔是否大于指定值，如果大于就丢弃已接收的数据，重新开始接收
	模拟环境下，不能判断超时*/
	rtime = tmr_get_time();

	if(((rtime - prinfo->rtime)  > UART_RCV_TIMEOUT) && (prinfo->rproc.outcnt != 0))
	{
		prinfo->rproc.outcnt = 0;
		memset(prinfo->rproc.pdata, 0, prinfo->rproc.datalen);
	}
#endif
	/*记录接收暂存缓冲区开始处理的位置*/
	index = prinfo->rtbuf.poutput;

	/*已经处理的报文字节计数*/
	ucnt = prinfo->rproc.outcnt;

	/*处理已经接收完毕但是还没有处理的报文内容*/
	while(index != prinfo->rtbuf.pinput)
	{
		/*获取接收缓冲区的内容*/
		val = prinfo->rtbuf.buf[index];
		
		if(ucnt == UART_RC006DELIMITER_POS)
		{/*还没有取过数据*/
			if(val == UART_RC006_DELIMITER)
			{/*定界符，记录处理长度*/
				prinfo->rproc.pdata[ucnt++] = val;
			}
			else
			{
				errflag = TRUE;
			}
		}
		else if(ucnt == UART_RC006DVERLEN_POS)
		{/*取完定界符了*/
			pverlen = (uart_rc006_verlen *)&val;
			if((pverlen->hlenleft == UART_RC006_HLENLEFT) && (pverlen->ver == UART_RC006_VER))
			{/*校验报文头长度和协议版本*/
				prinfo->rproc.pdata[ucnt++] = val;
			}
			/*panwei 2011-3-4 防止校验和是0x95,程序误认为是协议起始符*/
			else if(val == UART_RC006_DELIMITER)
			{
				ucnt = UART_RC006DELIMITER_POS;
				prinfo->rproc.pdata[ucnt++] = val;
			}
			else
			{
				errflag = TRUE;
			}
		}
		else if(ucnt == UART_RC006PKTLEN_HI_POS)
		{/*报文剩余长度的高字节*/
			prinfo->rproc.pdata[ucnt++] = val;
			prinfo->rproc.pktlen = val;
			prinfo->rproc.pktlen <<= 8;/*左移*/
		}
		else if(ucnt == UART_RC006PKTLEN_LOW_POS)
		{
			prinfo->rproc.pdata[ucnt++] = val;
			prinfo->rproc.pktlen |= val;
			/*判断长度是否合法*//*sunzhongbo  20090818加长度最下判断*/
			if((prinfo->rproc.pktlen > prinfo->rproc.datalen-ucnt)||(prinfo->rproc.pktlen<UART_RC006PKTLEN_MIN))
			{/*长度超过了缓冲区，肯定非法*/
				errflag = TRUE;
			}
		}
		else
		{/*接收净荷直至接收完成*/
			prinfo->rproc.pdata[ucnt++] = val;
			if(ucnt == prinfo->rproc.pktlen+UART_RC006PKTLEN_LOW_POS+1)
			{/*接收完成，调用注册函数进行处理*/
				if(prinfo->rproc.rcv == NULL)
				{/*没有注册接收函数，报错*/
					MCU_EXC_ERROR;
				}
				if(prinfo->rproc.rcv(arg, UART_PRTTYPE_006, prinfo->rproc.pdata, ucnt, NULL) != OK)
				{/*执行失败，报错*/
					MCU_EXC_ERROR;
				}
				/*执行完毕后清零长度计数*/
				ucnt = 0;
			}
		}

		if(errflag)
		{
			/*清除接收计数*/
			ucnt = 0;
			prinfo->errpkt++;/*接收错包统计累计*/
			/*panwei 2011-3-3*/
			errflag = FALSE;
		}

		/*处理下一个字符*/
		index = (index+1)%UART_RCV_TEMPBUF_LEN;
		
	}

	/*更新输出起始指针*/
	prinfo->rtbuf.poutput = index;
	prinfo->rproc.outcnt = ucnt;
	/*只要ucnt不为0，表示开始接收数据了，启定时器，超时后清除rproc中的缓冲和outcnt*/
	prinfo->rtime = tmr_get_time();
	
	
	return OK;	

#else
	NO_USE(arg);
	NO_USE(prinfo);
	return OK;
#endif	
}

#ifdef INCLUDE_OPTTYPE

/*******************************************************************************
*uart_rcv_process_opttype  存储光头类型模块,处理函数
*Input:
*	prinfo	--接收缓冲区相关信息指针；
*Output:
*	None	
*Return:
*	None
*/
OTP_VOID uart_rcv_process_opttype(OTP_VOID *arg, uart_rcv_info *prinfo)
{
	OTP_UINT8 val = 0;
	OTP_UINT16 index = 0, ucnt = 0;
#ifndef	OTP_RUN_SIMPC
	OTP_UINT32 rtime = 0;
#endif
	
	/*参数检查*/
	if(prinfo == NULL)
	{
		MCU_EXC_ERROR;
		return;
	}
	/*20090828modify,szb*/
	if(prinfo->flag.bufof==TRUE)
	{
		prinfo->flag.bufof=FALSE;
		prinfo->rtbuf.poutput = prinfo->rtbuf.pinput;
		prinfo->rproc.outcnt = 0; 
	}

	/*看看接收暂存缓冲区当前有没有数据可以接收*/
	if(prinfo->rtbuf.poutput == prinfo->rtbuf.pinput)
	{
		/*没有新数据*/
		return;
	}

#ifndef	OTP_RUN_SIMPC
	/*检查字节接收间隔是否大于指定值，如果大于就丢弃已接收的数据，重新开始接收
	模拟环境下，不能判断超时*/
	rtime = tmr_get_time();

	if(((rtime - prinfo->opttype.rtime)  > UART_RCV_TIMEOUT) && (prinfo->rproc.outcnt != 0))
	{
		prinfo->opttype.rtime = rtime;
		prinfo->opttype.ucnt = 0;
	}
#endif
	/*记录接收暂存缓冲区开始处理的位置*/
	index = prinfo->rtbuf.poutput;


	/*处理已经接收完毕但是还没有处理的报文内容*/
	while(index != prinfo->rtbuf.pinput)
	{
		/*已经处理的报文计数*/
		ucnt = prinfo->opttype.ucnt;

		/*获取接收缓冲区的内容*/
		val = prinfo->rtbuf.buf[index];

		if(ucnt == UART_OPTTYPE_SLOT_POS)
		{
			/*还没有取过数据*/
			if( ((val & UART_OPTTYPE_SLOT_MASK) == 0) 
				|| ((val & UART_OPTTYPE_SLOT_MASK) == svc_get_local_slot(arg)) )
			{
				/*slot*/
				prinfo->opttype.ucnt++;
			}
	
		}
		else if(ucnt == UART_OPTTYPE_IDENTYFY_POS)
		{
			/*标识*/
			if( val == UART_OPTTYPE_IDENTIFY )
			{
				prinfo->opttype.ucnt++;
			}
			else
			{
				prinfo->opttype.ucnt = 0;
			}
		}
		else if(ucnt == UART_OPTTYPE_LEN_POS)
		{
			/*长度*/
			val &= UART_OPTTYPE_LEN_MASK;
			/*长度包含扩展模块槽号配置标志和烧写数据局端远端及类型编码及净荷,
			UART_OPTTYPE_DATA_LEN只存储净荷*/
			if( (val <= UART_OPTTYPE_DATA_LEN + UART_OPTTYPE_LEN_EXCLUDE_BYTE)
				&& (val > UART_OPTTYPE_LEN_EXCLUDE_BYTE))
			{
				prinfo->opttype.len = val-UART_OPTTYPE_LEN_EXCLUDE_BYTE;
				prinfo->opttype.ucnt++;
			}
			else
			{
				prinfo->opttype.ucnt = 0;
			}
		}
		else if( (ucnt >= UART_OPTTYPE_DATA_POS) 
			&& (ucnt < UART_OPTTYPE_DATA_POS + prinfo->opttype.len) )
		{
			prinfo->opttype.data[ucnt - UART_OPTTYPE_DATA_POS] = val;
			prinfo->opttype.ucnt++;
		}
		else if((ucnt >= UART_OPTTYPE_DATA_POS + prinfo->opttype.len)
			&&(ucnt < UART_OPTTYPE_DATA_POS + prinfo->opttype.len+UART_OPTTYPE_EXTDENTIFY_LEN))
		{
			if( val == UART_OPTTYPE_IDENTIFY )
			{
				prinfo->opttype.ucnt++;
			}
			else
			{
				prinfo->opttype.ucnt = 0;
			}
		
		}
		else if( ucnt >= UART_OPTTYPE_DATA_POS + prinfo->opttype.len+UART_OPTTYPE_EXTDENTIFY_LEN ) 
		{
			if( val == UART_OPTTYPE_IDENTIFY )
			{
				if( NULL != prinfo->opttype.rcv )
				{
					if(prinfo->opttype.rcv(arg, UART_PRTTYPE_OPTTYPE, prinfo->opttype.data, prinfo->opttype.len, 0) != OK)
					{/*执行失败，报错*/
						MCU_EXC_ERROR;
					}
				}
				else
				{
					ASSERT(0);
				}
				
			}

			prinfo->opttype.ucnt = 0;		
		}
		else
		{
			prinfo->opttype.ucnt++;
		}
		/*处理下一个字符*/
		index = (index+1)%UART_RCV_TEMPBUF_LEN;
		
	}

}

#endif

/*******************************************************************************
*uart_rcv_process  接收报文处理，按照相应的协议，对接收缓冲区的报文进行处理，并调用
*		注册的rcv处理函数；
*Input:
*	prt		--报文处理使用的协议，根据协议类型进行报文接收；
*	prinfo	--接收缓冲区相关信息指针；
*Output:
*	None	
*Return:
*	OK/ERROR，表示执行成功和失败
*/
STATUS uart_rcv_process(OTP_VOID *arg, uart_protocol_type prt, uart_rcv_info *prinfo)
{

	/*接收缓冲区有新数据的情况下按照协议类型进行处理*/
#ifdef INCLUDE_OPTTYPE
	uart_rcv_process_opttype(arg, prinfo);
#endif
	/*lint -save -e788*/
	switch(prt)
	{
		case UART_PRTTYPE_002:
			return uart_rcv_process_rc002(arg, prinfo);

		case UART_PRTTYPE_004:
			return uart_rcv_process_rc004(arg, prinfo);			

		case UART_PRTTYPE_006:
			return uart_rcv_process_rc006(arg, prinfo);
			
		case UART_PRTTYPE_CONSOLE:
			return uart_rcv_process_console(arg, prinfo);

		case UART_PRTTYPE_INVALID:
			break;

		default:
			break;
	}
	/*lint -restore*/
	MCU_EXC_ERROR;
	return ERROR;
 }


/*******************************************************************************
*uart_msg_send 发送报文处理
*Input:
*	uid		--发送数据的URAT端口号
*	pinfo 	--串口信息处理结构指针
*	buf		--需要发送的数据指针
*	buflen	--发送的数据长度
*Output:
*	None	
*Return:
*	OK/ERROR，表示执行成功和失败
*/
STATUS uart_msg_send(OTP_UINT8 uid, uart_info *pinfo, const OTP_UINT8 *buf, OTP_UINT32 buflen)
{
	OTP_UINT16 i = 0, index = 0;
	
	if(pinfo == NULL)
	{
		MCU_EXC_ERROR;
		return ERROR;
	}

	if(pinfo->sinfo.flag.bufof)
	{/*发送的速度太慢了*/
		MCU_EXC_ERROR;
	/*为避免溢出后该函数失效，取消溢出标志位*/
		pinfo->sinfo.flag.bufof = 0;	
		return ERROR;
	}

	/*取缓冲区输入指针*/
	index = pinfo->sinfo.pinput;
	
	/*依次将需要发送的数据放入发送缓冲区*/
	for(i=0; i<buflen; i++)
	{
		pinfo->sinfo.pdata[index] = buf[i];
		/*模加index*/
		index = (index+1)%pinfo->sinfo.datalen;

		if(index == pinfo->sinfo.poutput)
		{
			pinfo->sinfo.flag.bufof = 1;
			MCU_EXC_ERROR;
		}
	}

	/*更新输入指针*/
	pinfo->sinfo.pinput = index;

	/*启动发送*/
	if((pinfo->sinfo.pinput  != pinfo->sinfo.poutput)&&(!pinfo->sinfo.sending))
	{
		(OTP_VOID)svc_uart_send_enable(uid);
		/*等待一下????*/
		pinfo->sinfo.sending = TRUE;
		index = pinfo->sinfo.poutput;
		UXDR_SET(UART_REG[uid], pinfo->sinfo.pdata[index]);/*新数据写入发送缓冲*/
		pinfo->sinfo.poutput = (index+1)%pinfo->sinfo.datalen;/*以datalen为模加index*/
	}
	

	return OK;
}


/*lint -restore*/

#endif

