/****************************************************************
	Copyright(C), 1999-2004 Raisecom, Inc.
	filename: uart.c，串口驱动函数核心文件
	Author	: qiaoqiangguo
	version	: 1.0
	date	: 2008/6/21
	Others	:
        THIS DOCUMENT IS GENERATED BY TORNADO TOOLS refgen.exe
        EXAMPLE:
        ->torVars.bat
        ->refgen -mg -out doc uart.c
        ->cd doc
        ->htmllink
*****************************************************************/


#include "pocket_hub_config.h"

#if (defined(INCLUDE_UART1) || defined(INCLUDE_UART2)|| defined(INCLUDE_UART3))

#include "string.h"

#include "type_common.h"
#include "uart_common.h"
#include "uart1.h"
#include "ibc.h"


#ifdef  INCLUDE_X_MODEM_COMM
#include "x_modem.h"
#endif 


#if 0
/*调用产品信息下载接收函数*/
#ifdef INCLUDE_PRODUCT_MSG_COMM_PRTCL
/*使能在CONSEL串口处理产品信息下载协议*/
#include "pdt_msg_com_ptl.h"

#ifdef INCLUDE_PRODUCT_MSG_COMM_PRTCL_CONSEL
#include "trace.h"
extern trace_msg_send g_msg_msg_send;		/*consol发送函数*/
#else
#ifdef INCLUDE_PRODUCT_MSG_COMM_PRTCL_RC006
#include "ibc.h"
//extern xxx_msg_send g_sync_send_func;		/*串口1发送函数*/
#endif
#endif
#endif
#endif


/*lint -save -e818*/


/*******************************************************************************
*uart_rcv_process_rc002  002协议接收报文处理，按照相应的协议，对接收缓冲区的报文进行处理，并调用
*		注册的rcv处理函数；
*Input:
*	prinfo	--接收缓冲区相关信息指针；
*Output:
*	None	
*Return:
*	OK/ERROR，表示执行成功和失败
*/
LOCAL STATUS uart_rcv_process_rc002(OTP_VOID *arg, uart_rcv_info *prinfo)
{
	NO_USE(arg);
	NO_USE(prinfo);
	return OK;
}


/*******************************************************************************
*uart_rcv_process_rc004  004协议接收报文处理，按照相应的协议，对接收缓冲区的报文进行处理，并调用
*		注册的rcv处理函数；
*Input:
*	prinfo	--接收缓冲区相关信息指针；
*Output:
*	None	
*Return:
*	OK/ERROR，表示执行成功和失败
*/
LOCAL STATUS uart_rcv_process_rc004(OTP_VOID *arg, uart_rcv_info *prinfo)
{
	NO_USE(arg);
	NO_USE(prinfo);
	return OK;
}

/*******************************************************************************
*uart_rcv_process_console  console接收报文处理，按照相应的协议，对接收缓冲区的报文进行处理，并调用
*		注册的rcv处理函数；
*Input:
*	prinfo	--接收缓冲区相关信息指针；
*Output:
*	None	
*Return:
*	OK/ERROR，表示执行成功和失败
*/
LOCAL STATUS uart_rcv_process_console(OTP_VOID *arg, uart_rcv_info *prinfo)
{
#ifdef INCLUDE_CLI
	OTP_UINT8 val = 0;
	OTP_UINT32 index = 0;
	OTP_UINT32 ucnt = 0;
	
	/*参数检查*/
	if(prinfo == NULL)
	{
		MCU_EXC_ERROR;
		return ERROR;
	}

	/*20090828modify,szb*/
	if(prinfo->flag.bufof==TRUE)
	{
		prinfo->flag.bufof=FALSE;
		prinfo->rtbuf.poutput = prinfo->rtbuf.pinput;
		prinfo->rproc.outcnt = 0; 
	}

	/*看看接收暂存缓冲区当前有没有数据可以接收*/
	if(prinfo->rtbuf.poutput == prinfo->rtbuf.pinput)
	{/*没有新数据*/
		return OK;
	}

/*调用产品信息下载接收函数*/
#ifdef INCLUDE_PRODUCT_MSG_COMM_PRTCL
/*使能在CONSEL串口处理产品信息下载协议*/
#ifdef INCLUDE_PRODUCT_MSG_COMM_PRTCL_CONSEL
    /*处于Xmodem程序升级下，不处理产品信息下载协议*/
	if (XMODEM_ENABLE != xmodem_get_message_state())
	{
		/*调用产品信息下载接收函数*/
		if(OK == pdt_msg_protocol_rcv(arg, (OTP_UINT16 *)&prinfo->rtbuf.pinput, 
                                     (OTP_UINT16 *)&prinfo->rtbuf.poutput, 
                                      prinfo->rtbuf.buf, UART_RCV_TEMPBUF_LEN))
		{
			return OK;
		}
	}
#endif
#endif
	
	/*记录接收暂存缓冲区开始处理的位置*/
	index = prinfo->rtbuf.poutput;

	/*处理已经接收完毕但是还没有处理的报文内容*/
	while(index != prinfo->rtbuf.pinput)
	{
		/*获取接收缓冲区的内容*/
		val = prinfo->rtbuf.buf[index];
		prinfo->rproc.pdata[ucnt++] = val;

		/*处理下一个字符*/
		index = (index+1)%UART_RCV_TEMPBUF_LEN;
		
	}

	if(prinfo->rproc.rcv == NULL)
	{/*没有注册接收函数，报错*/
		MCU_EXC_ERROR;
		return ERROR;
	}
	if(prinfo->rproc.rcv(arg, UART_PRTTYPE_CONSOLE, prinfo->rproc.pdata, ucnt, NULL) != OK)
	{/*执行失败，报错*/
		MCU_EXC_ERROR;
	}

	/*更新输出起始指针*/
	prinfo->rtbuf.poutput = index;
	
	return OK;

#else
	NO_USE(arg);
	NO_USE(prinfo);
	return OK;
#endif	
}

/*******************************************************************************
*uart_rcv_process_rc006  006协议接收报文处理，按照相应的协议，对接收缓冲区的报文进行处理，并调用
*		注册的rcv处理函数；
*Input:
*	prinfo	--接收缓冲区相关信息指针；
*Output:
*	None	
*Return:
*	OK/ERROR，表示执行成功和失败
*/
LOCAL STATUS uart_rcv_process_rc006(OTP_VOID *arg, uart_rcv_info *prinfo)
{
#ifdef INCLUDE_IBC_RC006
	OTP_UINT8 val = 0;
	OTP_UINT32 index = 0;
	OTP_UINT32 ucnt = 0;
#ifndef	OTP_RUN_SIMPC
	OTP_UINT32 rtime = 0;
#endif
	BOOL errflag = FALSE;
	uart_rc006_verlen *pverlen = NULL;
	
	/*参数检查*/
	if(prinfo == NULL)
	{
		MCU_EXC_ERROR;
		return ERROR;
	}
	/*20090828modify,szb*/
	if(prinfo->flag.bufof==TRUE)
	{
		prinfo->flag.bufof=FALSE;
		prinfo->rtbuf.poutput = prinfo->rtbuf.pinput;
		prinfo->rproc.outcnt = 0; 
	}

	/*看看接收暂存缓冲区当前有没有数据可以接收*/
	if(prinfo->rtbuf.poutput == prinfo->rtbuf.pinput)
	{/*没有新数据*/
		return OK;
	}

#ifndef	OTP_RUN_SIMPC
	/*检查字节接收间隔是否大于指定值，如果大于就丢弃已接收的数据，重新开始接收
	模拟环境下，不能判断超时*/
	rtime = tmr_get_time();

	if(((rtime - prinfo->rtime)  > UART_RCV_TIMEOUT) && (prinfo->rproc.outcnt != 0))
	{
		prinfo->rproc.outcnt = 0;
		memset(prinfo->rproc.pdata, 0, prinfo->rproc.datalen);
	}
#endif
	/*记录接收暂存缓冲区开始处理的位置*/
	index = prinfo->rtbuf.poutput;

	/*已经处理的报文字节计数*/
	ucnt = prinfo->rproc.outcnt;

	/*处理已经接收完毕但是还没有处理的报文内容*/
	while(index != prinfo->rtbuf.pinput)
	{
		/*获取接收缓冲区的内容*/
		val = prinfo->rtbuf.buf[index];
		
		if(ucnt == UART_RC006DELIMITER_POS)
		{/*还没有取过数据*/
			if(val == UART_RC006_DELIMITER)
			{/*定界符，记录处理长度*/
				prinfo->rproc.pdata[ucnt++] = val;
			}
			else
			{
				errflag = TRUE;
			}
		}
		else if(ucnt == UART_RC006DVERLEN_POS)
		{/*取完定界符了*/
			pverlen = (uart_rc006_verlen *)&val;
			if((pverlen->hlenleft == UART_RC006_HLENLEFT) && (pverlen->ver == UART_RC006_VER))
			{/*校验报文头长度和协议版本*/
				prinfo->rproc.pdata[ucnt++] = val;
			}
			/*panwei 2011-3-4 防止校验和是0x95,程序误认为是协议起始符*/
			else if(val == UART_RC006_DELIMITER)
			{
				ucnt = UART_RC006DELIMITER_POS;
				prinfo->rproc.pdata[ucnt++] = val;
			}
			else
			{
				errflag = TRUE;
			}
		}
		else if(ucnt == UART_RC006PKTLEN_HI_POS)
		{/*报文剩余长度的高字节*/
			prinfo->rproc.pdata[ucnt++] = val;
			prinfo->rproc.pktlen = val;
			prinfo->rproc.pktlen <<= 8;/*左移*/
		}
		else if(ucnt == UART_RC006PKTLEN_LOW_POS)
		{
			prinfo->rproc.pdata[ucnt++] = val;
			prinfo->rproc.pktlen |= val;
			/*判断长度是否合法*//*sunzhongbo  20090818加长度最下判断*/
			if((prinfo->rproc.pktlen > prinfo->rproc.datalen-ucnt)||(prinfo->rproc.pktlen<UART_RC006PKTLEN_MIN))
			{/*长度超过了缓冲区，肯定非法*/
				errflag = TRUE;
			}
		}
		else
		{/*接收净荷直至接收完成*/
			prinfo->rproc.pdata[ucnt++] = val;
			if(ucnt == prinfo->rproc.pktlen+UART_RC006PKTLEN_LOW_POS+1)
			{/*接收完成，调用注册函数进行处理*/
				if(prinfo->rproc.rcv == NULL)
				{/*没有注册接收函数，报错*/
					MCU_EXC_ERROR;
				}
				if(prinfo->rproc.rcv(arg, UART_PRTTYPE_006, prinfo->rproc.pdata, ucnt, NULL) != OK)
				{/*执行失败，报错*/
					MCU_EXC_ERROR;
				}
				/*执行完毕后清零长度计数*/
				ucnt = 0;
			}
		}

		if(errflag)
		{
			/*清除接收计数*/
			ucnt = 0;
			prinfo->errpkt++;/*接收错包统计累计*/
			/*panwei 2011-3-3*/
			errflag = FALSE;
		}

		/*处理下一个字符*/
		index = (index+1)%UART_RCV_TEMPBUF_LEN;
		
	}

	/*更新输出起始指针*/
	prinfo->rtbuf.poutput = index;
	prinfo->rproc.outcnt = ucnt;
	/*只要ucnt不为0，表示开始接收数据了，启定时器，超时后清除rproc中的缓冲和outcnt*/
	prinfo->rtime = tmr_get_time();
	
	
	return OK;	

#else
	NO_USE(arg);
	NO_USE(prinfo);
	return OK;
#endif	
}


/*******************************************************************************
*uart_rcv_process  接收报文处理，按照相应的协议，对接收缓冲区的报文进行处理，并调用
*		注册的rcv处理函数；
*Input:
*	prt		--报文处理使用的协议，根据协议类型进行报文接收；
*	prinfo	--接收缓冲区相关信息指针；
*Output:
*	None	
*Return:
*	OK/ERROR，表示执行成功和失败
*/
STATUS uart_rcv_process(OTP_VOID *arg, uart_protocol_type prt, uart_rcv_info *prinfo)
{

	/*接收缓冲区有新数据的情况下按照协议类型进行处理*/
	/*lint -save -e788*/
	switch(prt)
	{
		case UART_PRTTYPE_002:
			return uart_rcv_process_rc002(arg, prinfo);

		case UART_PRTTYPE_004:
			return uart_rcv_process_rc004(arg, prinfo);			

		case UART_PRTTYPE_006:
			return uart_rcv_process_rc006(arg, prinfo);
			
		case UART_PRTTYPE_CONSOLE:
			return uart_rcv_process_console(arg, prinfo);

		case UART_PRTTYPE_INVALID:
			break;

		default:
			break;
	}
	/*lint -restore*/
	MCU_EXC_ERROR;
	return ERROR;
 }


/*******************************************************************************
*uart_msg_send 发送报文处理
*Input:
*	uid		--发送数据的URAT端口号
*	pinfo 	--串口信息处理结构指针
*	buf		--需要发送的数据指针
*	buflen	--发送的数据长度
*Output:
*	None	
*Return:
*	OK/ERROR，表示执行成功和失败
*/
STATUS uart_msg_send(OTP_UINT8 uid, uart_info *pinfo, const OTP_UINT8 *buf, OTP_UINT32 buflen)
{
	OTP_UINT16 i = 0, index = 0;
	
	if(pinfo == NULL)
	{
		MCU_EXC_ERROR;
		return ERROR;
	}

	if(pinfo->sinfo.flag.bufof)
	{/*发送的速度太慢了*/
		MCU_EXC_ERROR;
	/*为避免溢出后该函数失效，取消溢出标志位*/
		pinfo->sinfo.flag.bufof = 0;	
		return ERROR;
	}


	return OK;
}


/*lint -restore*/

#endif

