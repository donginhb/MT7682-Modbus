/****************************************************************
	Copyright(C), 1999-2004 Raisecom, Inc.
	filename: ibc.c，板间协议处理函数
	Author	: qiaoqiangguo
	version	: 1.0
	date	: 2008/6/21
	Others	:
        THIS DOCUMENT IS GENERATED BY TORNADO TOOLS refgen.exe
        EXAMPLE:
        ->torVars.bat
        ->refgen -mg -out doc ibc.c
        ->cd doc
        ->htmllink
*****************************************************************/
#include "pocket_hub_config.h"

#ifdef INCLUDE_IBC_RC006
/*lint -save -e322 -e7*/
#include "string.h"
/*lint -restore*/

/*#include "macro_common.h"
#include "dev_common.h"
#include "trace.h"
#include "menu_toolkit.h"
#include "uart.h"
#include "ibc_rc006_protocol.h"
#include "ibc.h"
#include "ibc_rc006.h"*/

#include "type_common.h"
#include "macro_common.h"
#include "dev_common.h"
#include "uart_common.h"
#include "ibc_rc006_protocol.h"
#include "ibc.h"
#include "ibc_rc006.h"

/*rc006 ibc打包函数使用缓冲区*/
OTP_UINT8	g_ibc_msg_buf[IBC_RC006_MSG_BUF_LEN];

/*rc006 ibc 发送协议头*/
OTP_UINT8 g_ibc_msg_head[IBC_RC006_MSG_HEAD_LEN_MAX];

ibc_adp_info g_ibcadp_info;

/*业务盘上的业务模块处理从网管盘发来的数据并发送同步响应消息的函数*/
xxx_proc_nms_msg g_ibcadp_proc_nms_msg = NULL;

ibc_last_msg_info g_last_msg_cid[DEV_MAX_SERVICE_SLOT];

OTP_UINT8 g_sync_id = 0;

/*序列号*/
OTP_UINT8 g_ibc_seq = 0;

xxx_msg_send g_sync_send_func = NULL;

/*获取槽位号的函数*/
extern OTP_UINT8 svc_get_local_slot(const OTP_VOID *arg);
/*panwei 2011-7-27*/
extern OTP_UINT8	g_send_ena;
extern OTP_UINT8	g_rec_ena;

/*简单累加和的计算*/
LOCAL OTP_UINT8 crc_simple(const OTP_UINT8 * buf,OTP_UINT32 len)
{
	OTP_UINT8 crc=0;
	OTP_UINT32 i;
	for( i=0; i<len; i++)
	{
		crc += buf[i];
	}
	return crc;
}



/**********************************************************************************
*	从业务盘向网管盘发送同步消息的响应消息。隐含的目的槽位都是0
*	输入参数:
*		arg			无类型的指针，用于传递发送需要使用的函数指针，用户不需要理解
*		srcmsg,		收到的原始消息，用来向响应消息中填响应序列号和窗口号
*		prid,		扩展协议头中的远端设备标识,
*					如果为NULL，就是跳数为0，
*					否则按照指定跳数来封装扩展协议头
*		exrsp,		在响应消息中就是扩展响应字
*		data,		净荷块，函数调用者申请、填写和释放，
*		datalen,	data中有效数据的长度
*		
*	返回值:
*		OK,			消息成功进入发送队列
*		ERROR,		消息没有进入发送队列
*/
/*lint -save -e826*/
STATUS ibcadp_send(const OTP_VOID *arg,IBC_MSG srcmsg,const rdev_rid* prid,OTP_UINT8 exrsp,const OTP_UINT8 *data,OTP_UINT32 datalen)
{
	ibc_rc006_msg *pack = NULL, *psrc = NULL;
	OTP_UINT8 destslot=0, *msg = NULL, crc = 0;
	OTP_UINT32 i = 0, hlen = 0;
	/*lint -save -e611*/
#ifdef	INCLUDE_OPPOSITE_COMM
	comm_source_info *pcommsrcinfo = (comm_source_info *)arg;
	xxx_msg_send psfunc = pcommsrcinfo->send;
#else
	xxx_msg_send psfunc = (xxx_msg_send )arg;
#endif
	/*lint -restore*/
	if(srcmsg == NULL)
	{
		MCU_EXC_ERROR;
		return ERROR;
	}


	if(arg==NULL)
	{
		MCU_EXC_ERROR;
		return ERROR;
	}

	/*lint -save -e826*/
	psrc = (ibc_rc006_msg *)srcmsg;
	/*lint -restore*/
	/*目的槽位号*/
	destslot = psrc->head.srcslot;

	/*检查目的槽位号*/
	if(destslot>=DEV_MAX_SERVICE_SLOT )
	{
		MCU_EXC_ERROR;
		return ERROR;
	}

	pack = (ibc_rc006_msg *)g_ibc_msg_head;

	pack->head.framflag = IBC_FRAME_FLAG;
	pack->head.ver = IBC_VERSION;
	pack->head.hlenleft =IBC_HEADLEN2HLENLEFT(IBC_HEAD_LEN_V1_FIX);
	pack->head.destslot = destslot;
	pack->head.srcslot = svc_get_local_slot(arg);

	if(psrc->head.ssyncid == IBC_INVALID_SYNCID)
	{
		/*既然是同步消息，就不可能为这个值*/
		return ERROR;
	}
	pack->head.swinseqack = psrc->head.swinseq;
	pack->head.ssyncidack = psrc->head.ssyncid;
	pack->head.swinseq = g_ibc_seq++;/*统排的序列号，不保证连续*/
	pack->head.ssyncid = IBC_INVALID_SYNCID;
	pack->head.srcmod = psrc->head.destmod;
	pack->head.destmod = psrc->head.srcmod;


	/*msg指针，开始打包扩展协议头*/
	msg = pack->data;

	if((prid == NULL) || (prid->hop == 0))
	{
		*msg = 0;
		msg++;
	}
	else
	{
		/* 拷贝跳数 */
		*msg = prid->hop;
		msg++;
		
		for( i=0 ; i<prid->hop; i++ )
		{
			memcpy(msg, (OTP_VOID *)&prid->items[i].devt, sizeof(prid->items[i].devt));
			msg += sizeof(prid->items[i].devt);
			*msg = prid->items[i].rdevReserve;
			msg++;
			*msg = prid->items[i].devid;
			msg++;
		}
	}

	*msg = exrsp;
	msg++;

	/*协议头长度*/
	hlen =(OTP_UINT32)((msg - pack->data) +IBC_HEAD_LEN_V1_FIX );
	
	/*计算报文长度dlenleft*/
	pack->head.dlenleft = htons(IBC_DATALEN2DLENLEFT(hlen+IBC_CRC_LEN_V1+datalen));

	/*计算协议头和扩展协议头的crc*/
	crc = crc_simple(((OTP_UINT8 *)&pack->head)+1, hlen-1);
	/*累计数据的crc*/
	if(data != NULL)
	{
		crc += crc_simple(data, datalen);
	}
	

	if(psfunc(g_ibc_msg_head, hlen) != OK)
	{
		MCU_EXC_ERROR;
		return ERROR;
	}
	/*打印接收到的数据帧*/
	#if 0
	if(g_send_ena == ENABLE)
	{
		(OTP_VOID)printf("\r\nSend RC006 frames:\r\n");
		for ( i = 0 ; i < hlen; i++ )
		{
			(OTP_VOID)printf(" 0x");
			HEXshow(g_ibc_msg_head[i],1);
		}
	}
	#endif
	if(data && datalen)
	{
		if(psfunc((OTP_UINT8 *)(data), datalen) != OK)
		{
			MCU_EXC_ERROR;
			return ERROR;
		}
	}
	if(psfunc(&crc, IBC_CRC_LEN_V1) != OK)
	{
		MCU_EXC_ERROR;
		return ERROR;
	}

	/* 打印接收到的数据帧*/
		#if 0
		if(g_send_ena == ENABLE)
	{
		for ( i = 0 ; i < datalen; i++ )
		{
			/*lint -save -e613*/
			(OTP_VOID)printf(" 0x");
			HEXshow(*(data+i),1);
		}
		(OTP_VOID)printf(" 0x");
		HEXshow(crc,1);
		(OTP_VOID)printf(NEWLINE);
	}
		#endif

	return OK;
}

/*lint -restore*/



/*
	对刚从驱动收来的消息包进行字节序预处理并判断合法性。
	输入参数:
		pibcmsg,	驱动收到的板间消息包指针
		packetLen,	驱动收到的板间消息包的长度
	返回值:
		IBC_EXRSP_OK,	消息包合法
		其他,			消息包非法
*/
OTP_UINT8  ibc_packet_pretreat(ibc_rc006_msg *pibcmsg,OTP_UINT32 packetLen)
{

	/*起始字符*/
	if( pibcmsg->head.framflag != IBC_FRAME_FLAG )
	{
		return IBC_PACKET_ERROR_LEN_CRC;
	}

	/*协议头字节数，含framflag到协议头最后一个字节*/
	if( IBC_HLENLEFT2HEADLEN(pibcmsg->head.hlenleft) != IBC_HEAD_LEN_V1_FIX )
	{
		return IBC_PACKET_ERROR_LEN_CRC;
	}
	
	/*协议版本号，现在只允许一个版本的报文进来*/
	if( pibcmsg->head.ver != IBC_VERSION )
	{
		return IBC_PACKET_ERROR_VERSION;
	}

	
	/*数据包长度，含协议头和校验和*/
	if( IBC_DLENLEFT2DATALEN( ntohs(pibcmsg->head.dlenleft)) != packetLen )
	{
		return IBC_PACKET_ERROR_LEN_CRC;
	}

	if( pibcmsg->head.destslot>= DEV_MAX_SERVICE_SLOT ||	pibcmsg->head.srcslot>=DEV_MAX_SERVICE_SLOT )
	{
		return IBC_PACKET_ERROR_LEN_CRC;
	}
	if( pibcmsg->head.destmod!= IBC_MOD_ADAPTER || 	pibcmsg->head.srcmod != IBC_MOD_ADAPTER )
	{
		return IBC_PACKET_ERROR_LEN_CRC;
	}

	/* 不能对各个单盘的序列号产生算法做假设
	pibcmsg->head.seq.winseq;
	pibcmsg->head.seq.syncid;
	pibcmsg->head.seqack.winseq;
	pibcmsg->head.seqack.syncid;
	*/

	/*验证校验和，校验和不包括起始字符和校验码本身*/
	if( *(((OTP_UINT8*)&pibcmsg->head)+packetLen-IBC_CRC_LEN_V1) 
		!= crc_simple(((OTP_UINT8*)&pibcmsg->head)+1,(packetLen-1)-IBC_CRC_LEN_V1))
	{
		return IBC_PACKET_ERROR_LEN_CRC;
	}
	
	/*转换字节序*/
	pibcmsg->head.dlenleft = ntohs(pibcmsg->head.dlenleft);

	return IBC_PACKET_OK;
}

#ifdef IBC_ANSWER_NMS_ANYHOW
/*
	当收到错误消息的时候给网管盘发送响应消息
*/
STATUS ibc_send_answer_nms_anyhow(IBC_MSG srcmsg,OTP_UINT8 ibcckeck)
{
	OTP_UINT8 exrsp=IBC_PACKET_OK;

	/* 把IBC层的错误代码转换成适配层的代码 */
	switch(ibcckeck)
	{
		case IBC_PACKET_ERROR_VERSION:
			exrsp = IBC_EXRSP_ERROR_VERSION;
			break;
		case IBC_PACKET_ERROR_LEN_CRC:
			exrsp = IBC_EXRSP_ERROR_LEN_CRC;
			break;
		default:
			return ERROR;
	}

	/* 发送响应消息 */
	return ibcadp_send(srcmsg, NULL, exrsp, NULL, 0);
}
#endif

/*
	解包板间通信响应帧。
	输入参数
		pibcmsg,		板间消息指针
	输出参数
		prid，		返回消息包中的远端设备跳数和标识数组，如果为NULL就不返回。
					消息包跳数不能超过prid->hop,否则函数返回失败。
		pexrsp,		*pexrsp中为返回消息中的扩展响应字，如果调用者不关心这个，pexrsp可以为NULL
		pproclen,	输出参数，
					函数返回的时候(*prcvlen)表示本函数实际处理过的长度
	返回值
		OK,			成功
		ERROR,		失败
*/
STATUS ibcadp_unpack_frame(ibc_rc006_msg *pibcmsg, rdev_rid* prid, 
									OTP_UINT8*pexrsp,OTP_UINT32 *pproclen)
{
	rdev_rid* pridack=NULL;
	OTP_UINT32 i;

	/*初始化输出参数*/
	(*pproclen) = 0;
/*
	扩展协议头：
	
	跳数（1）	远端设备标识 4 * ( 0 ~ n )    操作类型码(发送)或扩展响应字节(接收) (1)
*/	
	/*lint -save -e826*/
	pridack = (rdev_rid*)(pibcmsg->data + (*pproclen));
	/*lint -restore*/
	if( prid )
	{
		/*返回跳数和设备标识*/
		if( pridack->hop > prid->hop )
		{
			return ERROR;
		}
		prid->hop = pridack->hop;
		
		/*指向远端设备标识数组*/
		(*pproclen)++;
		
		for( i=0; i<pridack->hop; i++ )
		{
			prid->items[i].devt = ntohs(pridack->items[i].devt);
			/*将保留字节改为扩展字节*/
			memcpy((OTP_UINT8 *)&(prid->items[i].devext), 
				(OTP_UINT8 *)&(pridack->items[i].devext), sizeof(pridack->items[i].devext));
			prid->items[i].devid = pridack->items[i].devid;
			/*指向扩展响应字*/
			(*pproclen) += sizeof(pridack->items[i]);
		}
	}
	else
	{
		/*简单判断一下，万一要是错误的呢，后面的实现不基于这个限制*/
		if( pridack->hop > RDEV_MAX_RID_NUM )
		{
			return ERROR;
		}
		/*指向扩展响应字*/
		(*pproclen) += 1 + sizeof(pridack->items[i])*pridack->hop;
	}
	
	/*扩展响应字*/
	if( pexrsp )
	{
		*pexrsp = *(pibcmsg->data + (*pproclen));
	}
	/*指向净荷*/
	(*pproclen)++;
	
	if( (*pproclen)> (OTP_UINT32)IBC_DATALEN2DLENLEFT(pibcmsg->head.dlenleft))
	{
		/*传入的数据区长度比前面分析过的长度都短，说明长度值不对*/
		return ERROR;
	}

	/*加上头长度*/
	(*pproclen) += IBC_HEAD_LEN_V1_FIX;
	
	return OK;
}


/*接收到的异步消息处理*/
STATUS ibcadp_msg_process(OTP_VOID *arg, OTP_UINT8 *pbuf, OTP_UINT16 len)
{
	ibc_rc006_msg *pibcmsg = NULL;
	OTP_UINT8 opcode=0, *pdatabuf = NULL;
	OTP_UINT32 proclen = 0;
	rdev_rid rid;

	/*参数检查*/
	if( !pbuf )
	{
		MCU_EXC_ERROR;
		return ERROR;
	}

	/*解包收到的消息*/
	memset(&rid,0,sizeof(rid));
	rid.hop = ARRAY_NITEM(rid.items);/*最大只取到这么多跳数了*/
	/*lint -save -e826*/
	pibcmsg = (ibc_rc006_msg *)pbuf;
	/*lint -restore*/
	if( ibcadp_unpack_frame(pibcmsg, &rid, &opcode,&proclen) != OK )
	{
		/*正处于环回状态*/
		if( g_ibcadp_info.isloopback )
		{
			/*单盘正处于环回状态，直接把报文原样送回*/
			(OTP_VOID)ibcadp_send(arg, pbuf, NULL, IBC_EXRSP_LOOPBACK, pbuf, len);
			return ERROR;
		}

#ifdef IBC_ANSWER_NMS_ANYHOW
		/*即使没有处理该消息也应该响应*/
		(OTP_VOID)ibcadp_send(arg, pbuf,NULL,IBC_EXRSP_ERROR_LEN_CRC,NULL,0);
#endif
		return ERROR;
	}
/*lint -save -e413 */
	if((proclen > len) || (proclen < IBC_HEAD_LEN_V1_FIX))
	{/*长度错误*/
		return ERROR;
	}
/*lint -restore*/
	/*数据开始位置*/
	pdatabuf = pibcmsg->data + proclen - IBC_HEAD_LEN_V1_FIX;

	/*收到取消环回的命令*/
	if( opcode == IBC_OPCODE_LOOPBACK_CANCEL)
	{
		g_ibcadp_info.isloopback = FALSE;
		/*回响应消息*/
		(OTP_VOID)ibcadp_send(arg, pbuf,NULL,IBC_EXRSP_OK,NULL,0);
		return ERROR;
	}

	/*收到设置环回命令*/
	if( opcode == IBC_OPCODE_LOOPBACK_SET)
	{
		g_ibcadp_info.isloopback = TRUE;
	}

	/*正处于环回状态*/
	if( g_ibcadp_info.isloopback )
	{
		/*单盘正处于环回状态，直接把报文文原样送回*/
		(OTP_VOID)ibcadp_send(arg, pbuf,NULL,IBC_EXRSP_LOOPBACK,pbuf,len);
		return ERROR;
	}

 	if(!g_ibcadp_proc_nms_msg)
 	{
#ifdef IBC_ANSWER_NMS_ANYHOW
		/*即使没有处理该消息也应该响应*/
		ibcadp_send(arg, pbuf,NULL,IBC_EXRSP_SKIP_OPCODE,NULL,0);
#endif

 			return ERROR;
 	}

 	if( g_ibcadp_proc_nms_msg(arg, pbuf, &rid,opcode,pdatabuf,(len-proclen)-1, g_ibc_msg_buf, IBC_RC006_MSG_BUF_LEN) != OK )
	{
		return ERROR;
	}
	
	return OK;
}

/*同步消息的响应处理*/
STATUS ibcadp_ackmsg_process(const OTP_VOID *arg,const OTP_UINT8 *pbuf, OTP_UINT16 len)
{
	NO_USE(len);
	NO_USE(arg);
	NO_USE(pbuf);
	return OK;
}



/********************************************************************************
*ibc_msg_rcv_rc006 --RC006协议接收报文处理函数
*Input:
*	arg			--自定义参数，传递发送报文使用的函数
*	pbuf		--接收到的报文头指针	
*	len			--接收的报文长度
*Output:
*	None
*Return:
*	OK			--表示执行成功
*	ERROR		--表示执行错误
*/
STATUS ibc_msg_rcv_rc006(OTP_VOID *arg,OTP_UINT8 *pbuf, OTP_UINT16 len)
{
	ibc_rc006_msg *pibcmsg = NULL;
	OTP_UINT8	tempdata;
	OTP_UINT16 i;
	
	/*参数检查*/
	if(pbuf == NULL)
	{
		MCU_EXC_ERROR;
		return ERROR;
	}
	/*打印接收到的数据帧*/
	if(g_rec_ena == ENABLE)
	{
		(OTP_VOID)printf("\r\nReceive RC006 frames:\r\n");
		for ( i = 0 ; i < len; i++ )
		{
			(OTP_VOID)printf(" 0x");
			HEXshow(*(pbuf+i),1);
		}
		(OTP_VOID)printf("\r\n");
	}
	
	pibcmsg = (ibc_rc006_msg *)pbuf;
	
	/*丢掉不属于本槽位的报文*/
	if( pibcmsg->head.destslot != svc_get_local_slot(arg))
	{
		return ERROR;
	}
	/*对于 长度检验和错误和协议版本错误的处理*/
	tempdata=ibc_packet_pretreat(pibcmsg, len);
	if(tempdata== IBC_PACKET_ERROR_LEN_CRC)
	{
		/*对于净荷长度和校验和错误的处理*/
		(OTP_VOID)ibcadp_send(arg, pbuf, NULL, IBC_EXRSP_ERROR_LEN_CRC, NULL,0);
		return ERROR;	
	}
	if(tempdata== IBC_PACKET_ERROR_VERSION)
	{
		/*对于协议版本错误的处理*/
		(OTP_VOID)ibcadp_send(arg, pbuf, NULL, IBC_EXRSP_ERROR_VERSION, NULL,0);
		return ERROR;	
	}	
	
	if(pibcmsg->head.ssyncid != IBC_INVALID_SYNCID)
	{/*如果是同步消息*/
		return ibcadp_msg_process(arg, pbuf, len);
	}
	else
	{/*同步消息的响应消息*/
		return ibcadp_ackmsg_process(arg, pbuf, len);
	}
	
}


/*********************************************************************************
*	从网管盘上向业务模块同步发送板间消息。
*	输入参数:
*		arg	,自定义参数，传递发送报文使用的函数
*		destslot,	目的槽位号
*		prid,		远端设备标识指针，为NULL或跳数为0的时候表示发送给局端单盘，函数调用者申请、填写和释放。
*		opcode,		操作码类型
*		data,		具体消息数据(协议中的净荷)，函数调用者申请、填写和释放。
*					如果没有数据要发送，填NULL。
*		datalen,	data中有效数据的长度。如果没有数据要发送，填0。
*		prcvlen,	同时做输入和输出参数，如果不需要输出净荷，可以为NULL。
*					调用函数的时候(*prcvlen)表示rcvbuf的长度，
*					当长度大于0的时候表示调用者希望得到响应消息的净荷，否则不输出净荷。
*		priority,	发送优先级，IBC_PRIORITY_PREMIER、IBC_PRIORITY_HIGH或IBC_PRIORITY_LOW
*		timeout,	超时tick数,大于0,时间为从驱动发送完消息以后算起，超时时间不包括发送队列处理时间。
*	输出参数:
*		rcvbuf,		接收数据缓冲区
*					函数调用者申请和释放，本函数内部填写，如果不需要输出净荷，可以为NULL
*		prcvlen,	同时做输入和输出参数，如果不需要输出净荷，可以为NULL。
*					函数返回的时候(*prcvlen)表示本函数实际拷贝进rcvbuf的数据长度
*		pexrsp,		*pexrsp中为返回消息中的扩展响应字，如果调用者不关心这个，pexrsp可以为NULL
*	返回值:
*		OK,			同步发送成功，如果rcvbuf不为空，其中已经有了返回的数据。
*		IBC_ERROR_INNER	数据错误，资源不够等错误
*		IBC_ERROR_QUEUE_FULL 发送队列满
*		IBC_ERROR_INVALID_DATA 数据无效
*		IBC_ERROR_FAILED_SENDING 发送失败
*		IBC_ERROR_NO_REPLY 无响应
*		IBC_ERROR_BAD_REPLY 响应数据有错
*		IBC_ERROR_LOOPBACK 设置了板间消息环回，就不向上层传递返回的报文了
*/
STATUS ibcadp_send_sync(const OTP_VOID *arg, OTP_UINT8 destslot,const rdev_rid* prid,OTP_UINT8 opcode,
								OTP_UINT8 *data,OTP_UINT32 datalen,	OTP_INT32 timeout)
{
#if 1
	ibc_rc006_msg *pack = NULL;
	OTP_UINT8 *msg = NULL, crc = 0;
	OTP_UINT32 i = 0, hlen = 0;
	

	/*检查目的槽位号*/
	if(destslot>=DEV_MAX_SERVICE_SLOT )
	{
		MCU_EXC_ERROR;
		return ERROR;
	}

	pack = (ibc_rc006_msg *)g_ibc_msg_head;

	pack->head.framflag = IBC_FRAME_FLAG;
	pack->head.ver = IBC_VERSION;
/*lint -save -e413 */
	pack->head.hlenleft = IBC_HEADLEN2HLENLEFT(IBC_HEAD_LEN_V1_FIX);
/*lint -restore*/	
	
	pack->head.destslot = destslot;
	pack->head.srcslot = svc_get_local_slot(arg);

	/*获取发送的同步号*/

	pack->head.swinseqack = g_last_msg_cid[destslot].lrseq;
	pack->head.ssyncidack = IBC_INVALID_SYNCID;
	pack->head.swinseq = g_ibc_seq++;/*统排的序列号，不保证连续*/
	/*wuruofeng 20090819 解决问题：协议要求此序列号不超过15*/
	pack->head.ssyncid = (g_sync_id++)&0x0f;
	
	pack->head.srcmod = IBC_MOD_ADAPTER;
	pack->head.destmod = IBC_MOD_ADAPTER;

	/*记录发送的seq和scid，接收响应消息时校验用*/
	g_last_msg_cid[destslot].lsseq = pack->head.swinseq;
	g_last_msg_cid[destslot].lsscid = pack->head.ssyncid;

	/*msg指针，开始打包扩展协议头*/
	msg = pack->data;

	if((prid == NULL) || (prid->hop == 0))
	{
		*msg = 0;
		msg++;
	}
	else
	{
		/* 拷贝跳数 */
		*msg = prid->hop;
		msg++;
		
		for( i=0 ; i<prid->hop; i++ )
		{
			memcpy(msg, (OTP_VOID *)&prid->items[i].devt, sizeof(prid->items[i].devt));
			msg += sizeof(prid->items[i].devt);
			*msg = prid->items[i].rdevReserve;
			msg++;
			*msg = prid->items[i].devid;
			msg++;
		}
	}

	*msg = opcode;
	msg++;

	/*协议头长度*/
/*lint -save -e413 */	
	hlen = (OTP_UINT32)((msg - pack->data) +IBC_HEAD_LEN_V1_FIX );
/*lint -restore*/	
	/*计算报文长度dlenleft*/
	pack->head.dlenleft = htons(IBC_DATALEN2DLENLEFT(hlen+IBC_CRC_LEN_V1+datalen));

	/*计算协议头和扩展协议头的crc*/
	crc = crc_simple(((OTP_UINT8 *)&pack->head)+1, hlen-1);
	/*累计数据的crc*/
	if(data != NULL)
	{
		crc += crc_simple(data, datalen);
	}

	if(g_sync_send_func == NULL)
	{
		MCU_EXC_ERROR;
		return ERROR;
	}

	if(g_sync_send_func(g_ibc_msg_head, hlen) != OK)
	{
		MCU_EXC_ERROR;
		return ERROR;
	}
	if(data && datalen)
	{
		if(g_sync_send_func(data, datalen) != OK)
		{
			MCU_EXC_ERROR;
			return ERROR;
		}
	}
	if(g_sync_send_func(&crc, IBC_CRC_LEN_V1) != OK)
	{
		MCU_EXC_ERROR;
		return ERROR;
	}

	/*启超时时间定时器*/
	/*tmr_create(timeout, TMR_DEFAULT, func)*/
#endif
	NO_USE(timeout);
	return OK;
}

/*****************************************************************************
*ibc_rc006_init		ibc初始化函数
*
*/
OTP_VOID ibc_rc006_init(void)
{
	memset(g_ibc_msg_buf, 0, sizeof(g_ibc_msg_buf));
	memset(g_ibc_msg_head, 0, sizeof(g_ibc_msg_head));
	memset(&g_ibcadp_info, 0, sizeof(g_ibcadp_info));
	g_ibcadp_proc_nms_msg = NULL;
	memset(g_last_msg_cid, 0, sizeof(g_last_msg_cid));

	g_sync_id = 0;
	g_ibc_seq = 0;
	g_sync_send_func = NULL;
}


#endif
